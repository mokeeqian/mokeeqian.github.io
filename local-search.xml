<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图论搜索模板</title>
    <link href="/2022/12/20/%E5%9B%BE%E8%AE%BA%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%9D%BF/"/>
    <url>/2022/12/20/%E5%9B%BE%E8%AE%BA%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a class="markdownIt-Anchor" href="#0-前言"></a> 0. 前言</h1><p>一直以来，图论相关的算法掌握就不是很好，甚至于，何时该用DFS，何时该用BFS有时都分不清。碰巧最近在刷图论相关的专题，当然作为非科班选手，掌握基础的DFS、BFS、最短路、连通块等知识，应付面试应该是够了。</p><p>在开始之前，有必要说一下DFS其实是有两种应用场景的：</p><ul><li>搜索：此搜索一般是用于暴力递归搜索解空间，得到所有的可行解（例如回溯）</li><li>图论：在图的场景下，是对图的遍历</li></ul><h2 id="dfs暴力搜索"><a class="markdownIt-Anchor" href="#dfs暴力搜索"></a> DFS暴力搜索</h2><p>顺便记录一下DFS暴搜的过程吧，也就是所谓的回溯，模板如下：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Gao</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 最终答案</span>    <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">></span></span> path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 中间答案</span>    <span class="token keyword">void</span> <span class="token function">gao</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">back_trace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> 条件满足 <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 枚举所有可能的情况</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> x in valids <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            path<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 加入答案</span>            <span class="token function">back_trace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 递归搜索</span>            path<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 撤销</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>最经典的问题，例如排列问题、组合问题、N皇后问题等。<br />例如：</p><p>LC797. 所有可能的路径</p><blockquote><p>给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）。</p><p>graph[i] 是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 graph[i][j]存在一条有向边）。</p><p>来源：力扣（LeetCode）<br />链接：<a href="https://leetcode.cn/problems/all-paths-from-source-to-target">https://leetcode.cn/problems/all-paths-from-source-to-target</a><br />著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">allPathsSourceTarget</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> graph<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">)</span>        <span class="token comment"># x: 当前处理到的节点</span>        <span class="token keyword">def</span> <span class="token function">back_trace</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> x <span class="token operator">==</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">return</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>graph<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                path<span class="token punctuation">.</span>append<span class="token punctuation">(</span>graph<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                back_trace<span class="token punctuation">(</span>graph<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                path<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        back_trace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="1-二维网格问题"><a class="markdownIt-Anchor" href="#1-二维网格问题"></a> 1. 二维网格问题</h1><p>二维网格问题是一类特殊的图论问题。基于一个二维数组，其中，单元格可看作是node，与单元格上下左右相邻的单元格可看作是其邻居node，上下左右关系可看作是edge。</p><h2 id="一些trick"><a class="markdownIt-Anchor" href="#一些trick"></a> 一些trick</h2><ul><li>dir 数组控制方向流转</li><li>有时初始的 grid 数组可以原地修改，作为 vis 标记和答案记录</li><li>BFS 中的队列设计，可以加入状态记录</li><li>关于从谁开始搜索：有时可以转换思路，源点和终点反过来，避免 TLE（LC 1162）</li><li>有时可以使用多源 BFS 加速搜索过程（LC 934）</li></ul><h2 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h2><p>网格上的DFS比较简单，如下：</p><p>LC 200. 岛屿数量</p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">numIslands</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 连通块个数</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 标记连通块</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'1'</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token operator">++</span>res<span class="token punctuation">;</span>                    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// (i, j)是坐标</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> g<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> g<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">>=</span> g<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'1'</span> <span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'2'</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h2><p>使用场景</p><ul><li>最短路径问题：基于BFS的性质，BFS首先访问的，一定是最短路</li><li>需要模拟层次扩散逻辑</li></ul><p>LC 1091. 二进制矩阵中的最短路径</p><div class="code-wrapper"><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">shortestPathBinaryMatrix</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> grid<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dirs<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> q<span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">pair</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// grid充当vis和答案记录</span>        grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">auto</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 当前的距离</span>            <span class="token keyword">int</span> dis <span class="token operator">=</span> grid<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> d <span class="token operator">:</span> dirs <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> nx <span class="token operator">=</span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> x<span class="token punctuation">,</span> ny <span class="token operator">=</span> d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> y<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span> nx <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> nx <span class="token operator">>=</span> n <span class="token operator">||</span> ny <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> ny <span class="token operator">>=</span> n <span class="token operator">||</span> grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                grid<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">=</span> dis <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">pair</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>                        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> grid<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> grid<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="2-普通图问题"><a class="markdownIt-Anchor" href="#2-普通图问题"></a> 2. 普通图问题</h1><p>一般的，图的存储实现有邻接表、邻接矩阵、链式前向星等。</p><p>需要注意的是，存储方式不同，DFS、BFS的实现也有一些不同。</p><h2 id="dfs-2"><a class="markdownIt-Anchor" href="#dfs-2"></a> DFS</h2><p>大致结构</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">DFS(v) &#x2F;&#x2F; v 可以是图中的一个顶点，也可以是抽象的概念，如 dp 状态等。  在 v 上打访问标记  for u in v 的相邻节点    if u 没有打过访问标记 then      DFS(u)    end  endend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="bfs-2"><a class="markdownIt-Anchor" href="#bfs-2"></a> BFS</h2><p>BFS 算法找到的路径是从起点开始的 最短 合法路径。换言之，这条路径所包含的边数最小。</p><p>在 BFS 结束时，每个节点都是通过从起点到该点的最短路径访问的。</p><p>应用场景</p><ul><li>在一个无权图上求从起点到其他所有点的最短路径</li><li>在一个有向无权图中找最小环（从每个点开始 BFS，在我们即将抵达一个之前访问过的点开始的时候，就知道遇到了一个环。图的最小环是每次 BFS 得到的最小环的平均值。）</li><li>在一个边权为 0/1 的图上求最短路（0-1 BFS）</li></ul><p>大致结构</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">bfs(s) &#123;  q &#x3D; new queue()  q.push(s), visited[s] &#x3D; true  while (!q.empty()) &#123;    &#x2F;&#x2F; 如果要涉及到层级关系的，要把分层逻辑抽出来    u &#x3D; q.pop()    for each edge(u, v) &#123;      if (!visited[v]) &#123;        q.push(v)        visited[v] &#x3D; true      &#125;    &#125;  &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="多源bfs"><a class="markdownIt-Anchor" href="#多源bfs"></a> 多源BFS</h2><p>前面所说的，一般都是从单个源点到单个终点的BFS，此时求最短路过程中，极其容易 TLE ，可以使用多源 BFS 加速。</p><p>LC 542. 01 矩阵</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">updateMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> g<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> g<span class="token punctuation">.</span>length<span class="token punctuation">,</span> n <span class="token operator">=</span> g<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dirs <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>        <span class="token class-name">Deque</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 状态描述：0 距离为0；-1,当前的“1”未访问; > 0，距离 </span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>i<span class="token punctuation">,</span> j<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 当前的 1 未访问</span>                <span class="token keyword">else</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 从所有的 0 开始多源BFS</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> xy <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> xy<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y <span class="token operator">=</span> xy<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">:</span> dirs <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">// 其邻居是未被访问的 1，即可确定最短距离</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span> nx <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nx <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> ny <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ny <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> g<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    g<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                    q<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> g<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>LC 934. 最短的桥</p><blockquote><p>给你一个大小为 n x n 的二元矩阵 grid ，其中 1 表示陆地，0 表示水域。</p><p>岛是由四面相连的 1 形成的一个最大组，即不会与非组内的任何其他 1 相连。grid 中 恰好存在两座岛 。<br />你可以将任意数量的 0 变为 1 ，以使两座岛连接起来，变成 一座岛 。返回必须翻转的 0 的最小数目</p><p>来源：力扣（LeetCode）<br />链接：<a href="https://leetcode.cn/problems/shortest-bridge">https://leetcode.cn/problems/shortest-bridge</a><br />著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span><span class="token operator">:</span>    queue<span class="token generics"><span class="token punctuation">&lt;</span>pair<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">></span><span class="token punctuation">></span></span> q<span class="token punctuation">;</span>    <span class="token keyword">int</span> dirs<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">shortestBridge</span><span class="token punctuation">(</span>vector<span class="token generics"><span class="token punctuation">&lt;</span>vector<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 将其中一个连通块标记为2 </span>                <span class="token keyword">if</span> <span class="token punctuation">(</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token function">dfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 多源 BFS</span>                    <span class="token keyword">return</span> <span class="token function">bfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 搜索连通块</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token generics"><span class="token punctuation">&lt;</span>vector<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token operator">&amp;</span> g<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> g<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">>=</span> g<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token comment">// visited</span>        g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>        q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 直接emplace(i, j)也行</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> auto<span class="token operator">&amp;</span> d <span class="token operator">:</span> dirs <span class="token punctuation">)</span> <span class="token function">dfs</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>i<span class="token punctuation">,</span> d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">bfs</span><span class="token punctuation">(</span>vector<span class="token generics"><span class="token punctuation">&lt;</span>vector<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token operator">&amp;</span> g<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> size <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span> size<span class="token operator">--</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                auto <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span> auto<span class="token operator">&amp;</span> d <span class="token operator">:</span> dirs <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">int</span> nx <span class="token operator">=</span> x<span class="token operator">+</span>d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y<span class="token operator">+</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span> nx <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nx <span class="token operator">&lt;</span> g<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> ny <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ny <span class="token operator">&lt;</span> g<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span> g<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">==</span>  <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            g<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                            q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token comment">// BFS 第一个找到的，一定是最短路</span>                        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> g<span class="token punctuation">[</span>nx<span class="token punctuation">]</span><span class="token punctuation">[</span>ny<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token operator">++</span>res<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="3-二分图"><a class="markdownIt-Anchor" href="#3-二分图"></a> 3. 二分图</h1><p>二分图，又称二部图，英文名叫 Bipartite graph。</p><p>二分图是什么？节点由两个集合组成，且两个集合内部没有边的图。</p><p>换言之，存在一种方案，将节点划分成满足以上性质的两个集合。</p><p><img src="https://oi-wiki.org/graph/images/bi-graph.svg" alt="二分图" /></p><p>性质</p><ul><li>如果两个集合中的点分别染成黑色和白色，可以发现二分图中的每一条边都一定是连接一个黑色点和一个白色点。</li><li>二分图不存在长度为奇数的环（因为每一条边都是从一个集合走到另一个集合，只有走偶数次才可能回到同一个集合。）</li></ul><p>判定</p><ul><li>红蓝染色法</li></ul><p>LC 785. 判断二分图</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">boolean</span> valid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> color<span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> g<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isBipartite</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> graph<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        color <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>graph<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        g <span class="token operator">=</span> graph<span class="token punctuation">;</span>        <span class="token comment">// 遍历每个联通分量</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> g<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> color<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>valid <span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> valid<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 染色法判定二分图</span>        color<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> next <span class="token operator">:</span> g<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 未访问，间隔染色</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> color<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> <span class="token operator">-</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span>valid <span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> color<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">==</span> c <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 相邻节点颜色一样，必然不是二分图</span>                valid <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="4-图论性质"><a class="markdownIt-Anchor" href="#4-图论性质"></a> 4. 图论性质</h1><p>有些题目，属于脑筋急转弯一类，可能并不需要遍历图，而是利用图的性质。</p><ul><li>入度、出度（LC 997）</li><li>连通分量（LC 1319）</li><li>etc</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
      <tag>并查集</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/09/24/LeetCode2022%E7%A7%8B%E5%AD%A3%E7%BC%96%E7%A8%8B%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2022/09/24/LeetCode2022%E7%A7%8B%E5%AD%A3%E7%BC%96%E7%A8%8B%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="httpszhuanlanzhihucomp593130098"><a class="markdownIt-Anchor" href="#httpszhuanlanzhihucomp593130098"></a> #! <a href="https://zhuanlan.zhihu.com/p/593130098">https://zhuanlan.zhihu.com/p/593130098</a></h2><h2 id="title-leetcode-2022秋季编程赛总结date-2022-09-24-191315tags-刷题categories-算法与数据结构"><a class="markdownIt-Anchor" href="#title-leetcode-2022秋季编程赛总结date-2022-09-24-191315tags-刷题categories-算法与数据结构"></a> title: LeetCode 2022秋季编程赛总结<br />date: 2022-09-24 19:13:15<br />tags:<br />- 刷题<br />categories:<br />- 算法与数据结构</h2><meta name="referrer" content="no-referrer" /><h1 id="0前言"><a class="markdownIt-Anchor" href="#0前言"></a> 0.前言</h1><p>刚开始迟到了十几分钟，一个半小时，只A了三道，后面两道战术性放弃。最终排名836，也算是意料之外了。</p><h1 id="1气温变化趋势"><a class="markdownIt-Anchor" href="#1气温变化趋势"></a> 1.气温变化趋势</h1><h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2><p>力扣城计划在两地设立「力扣嘉年华」的分会场，气象小组正在分析两地区的气温变化趋势，对于第 i ~ (i+1) 天的气温变化趋势，将根据以下规则判断：</p><p>若第 i+1 天的气温 高于 第 i 天，为 上升 趋势<br />若第 i+1 天的气温 等于 第 i 天，为 平稳 趋势<br />若第 i+1 天的气温 低于 第 i 天，为 下降 趋势<br />已知 temperatureA[i] 和 temperatureB[i] 分别表示第 i 天两地区的气温。<br />组委会希望找到一段天数尽可能多，且两地气温变化趋势相同的时间举办嘉年华活动。请分析并返回<strong>两地气温变化趋势相同的最大连续天数</strong>。</p><p>即最大的 n，使得第 i~i+n 天之间，两地气温变化趋势相同</p><p>示例 1：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：temperatureA <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">]</span>temperatureB <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">]</span>输出：<span class="token number">2</span>解释：如下表所示， 第 <span class="token number">2</span>～<span class="token number">4</span> 天两地气温变化趋势相同，且持续时间最长，因此返回 <span class="token number">4</span><span class="token operator">-</span><span class="token number">2</span><span class="token operator">=</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2><ul><li>直接计算出A、B两地的气温变换趋势，存入两个数组</li><li>遍历数组，更新最大相同子数组长度</li><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>；空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">temperatureTrend</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temperatureA<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temperatureB<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> temperatureA<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">gao</span><span class="token punctuation">(</span>temperatureA<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> temperatureA<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            b<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">gao</span><span class="token punctuation">(</span>temperatureB<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> temperatureB<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span> cnt<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment">// 更新最大值，重新计数</span>            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>                cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">gao</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> a <span class="token operator">==</span> b <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>a <span class="token operator">></span> b <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="2交通枢纽"><a class="markdownIt-Anchor" href="#2交通枢纽"></a> 2.交通枢纽</h1><h2 id="题目-2"><a class="markdownIt-Anchor" href="#题目-2"></a> 题目</h2><p>为了缓解「力扣嘉年华」期间的人流压力，组委会在活动期间开设了一些交通专线。path[i] = [a, b] 表示有一条从地点 a通往地点 b 的 单向 交通专线。<br />若存在一个地点，满足以下要求，我们则称之为 交通枢纽：</p><ul><li>所有地点（除自身外）均有一条 单向 专线 直接 通往该地点；</li><li>该地点不存在任何 通往其他地点 的单向专线。<br />请返回交通专线的 交通枢纽。若不存在，则返回 -1。</li></ul><p>注意：</p><ul><li>对于任意一个地点，至少被一条专线连通。</li></ul><p>示例 1：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>输出：<span class="token number">3</span>解释：如下图所示：地点 <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span> 各有一条通往地点 <span class="token number">3</span> 的交通专线，且地点 <span class="token number">3</span> 不存在任何通往其他地点的交通专线。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h2><p>无需建图，直接统计节点出入度数。出度<mark>0 &amp;&amp; 入度</mark>n-1的节点就是交通枢纽</p><h2 id="代码-2"><a class="markdownIt-Anchor" href="#代码-2"></a> 代码</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">transportationHub</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1001</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1001</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 统计节点个数</span>        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">:</span> path <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            out<span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            in<span class="token punctuation">[</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1001</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> in<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> set<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> out<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="3弹珠游戏"><a class="markdownIt-Anchor" href="#3弹珠游戏"></a> 3.弹珠游戏</h1><h2 id="题目-3"><a class="markdownIt-Anchor" href="#题目-3"></a> 题目</h2><p>欢迎各位来到「力扣嘉年华」，接下来将为各位介绍在活动中广受好评的弹珠游戏。</p><p>N*M 大小的弹珠盘的初始状态信息记录于一维字符串型数组 plate 中，数组中的每个元素为仅由 “O”、“W”、“E”、&quot;.&quot; 组成的字符串。其中：</p><ul><li>“O” 表示弹珠洞（弹珠到达后会落入洞中，并停止前进）；</li><li>“W” 表示逆时针转向器（弹珠经过时方向将逆时针旋转 90 度）；</li><li>“E” 表示顺时针转向器（弹珠经过时方向将顺时针旋转 90 度）；</li><li>“.” 表示空白区域（弹珠可通行）。</li><li></li></ul><p>游戏规则要求仅能在边缘位置的 空白区域 处（弹珠盘的四角除外）沿 与边缘垂直 的方向打入弹珠，并且打入后的每颗弹珠最多能 前进 num 步。请返回符合上述要求且可以使弹珠最终入洞的所有打入位置。你可以 按任意顺序 返回答案。</p><p>注意：</p><ul><li>若弹珠已到达弹珠盘边缘并且仍沿着出界方向继续前进，则将直接出界</li></ul><p>示例 1：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java">输入：num <span class="token operator">=</span> <span class="token number">4</span>plate <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"..E."</span><span class="token punctuation">,</span><span class="token string">".EOW"</span><span class="token punctuation">,</span><span class="token string">"..W."</span><span class="token punctuation">]</span>输出：<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>解释：在 <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> 处打入弹珠，弹珠前进 <span class="token number">1</span> 步后遇到转向器，前进方向顺时针旋转 <span class="token number">90</span> 度，再前进 <span class="token number">1</span> 步进入洞中。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>来源：力扣（LeetCode）<br />链接：<a href="https://leetcode.cn/problems/EXvqDp">https://leetcode.cn/problems/EXvqDp</a><br />著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h2><p>直接DFS，从四个边界开始，看在num步之内是否能到达“O”之处。注意，四个边角要除外；另外，方向的处理使用dir数组来取模转移。</p><p><code>int[][] dirs = new int[][]&#123;&#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;&#125;;</code></p><h2 id="代码-3"><a class="markdownIt-Anchor" href="#代码-3"></a> 代码</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> g<span class="token punctuation">;</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token comment">// 上，右，下，左（顺时针）</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dirs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">ballGame</span><span class="token punctuation">(</span><span class="token keyword">int</span> _num<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> plate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        num <span class="token operator">=</span> _num<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> plate<span class="token punctuation">.</span>length<span class="token punctuation">,</span> m <span class="token operator">=</span> plate<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        g <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> plate<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 从第一行，最后一行开始进入</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> g<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'.'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> g<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'.'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">dfs</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 第一列，最后一列</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'.'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'.'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span>i<span class="token punctuation">,</span> m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tt <span class="token operator">:</span> res<span class="token punctuation">)</span> ans<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span>tt<span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">boolean</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> step<span class="token punctuation">,</span> <span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> step <span class="token operator">></span> num <span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'O'</span> <span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment">// 新坐标</span>        <span class="token keyword">int</span> dx <span class="token operator">=</span> i <span class="token operator">+</span> dirs<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dy <span class="token operator">=</span> j <span class="token operator">+</span> dirs<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token function">out</span><span class="token punctuation">(</span>dx<span class="token punctuation">,</span> dy<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>dx<span class="token punctuation">,</span> dy<span class="token punctuation">,</span> step<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token function">nextIdx</span><span class="token punctuation">(</span>dx<span class="token punctuation">,</span> dy<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">boolean</span> <span class="token function">out</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> g<span class="token punctuation">.</span>length <span class="token operator">||</span> j<span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">>=</span> g<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">nextIdx</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 逆时针，+3</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'W'</span> <span class="token punctuation">)</span> idx <span class="token operator">=</span> <span class="token punctuation">(</span>idx<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">;</span>        <span class="token comment">// 顺时针，+1</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'E'</span> <span class="token punctuation">)</span> idx <span class="token operator">=</span> <span class="token punctuation">(</span>idx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> idx<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis高可拓展-分片技术</title>
    <link href="/2022/08/09/Redis%E9%AB%98%E5%8F%AF%E6%8B%93%E5%B1%95-%E5%88%86%E7%89%87%E6%8A%80%E6%9C%AF/"/>
    <url>/2022/08/09/Redis%E9%AB%98%E5%8F%AF%E6%8B%93%E5%B1%95-%E5%88%86%E7%89%87%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="0前言"><a class="markdownIt-Anchor" href="#0前言"></a> 0.前言</h1><p>Redis提供主从复制和哨兵集群机制，搭建主从架构来保证高可用。<br />如果<strong>海量数据+高并发+高可用</strong>场景，该怎么办？<br />Redis cluster，主要是针对海量数据+高并发+高可用的场景。Redis cluster 支撑 N 个 Redis master node，每个 master node 都可以挂载多个 slave node。这样整个 Redis 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。</p><h1 id="1redis-cluster介绍"><a class="markdownIt-Anchor" href="#1redis-cluster介绍"></a> 1.Redis Cluster介绍</h1><ul><li>自动将数据进行分片，每个 master 上放一部分数据</li><li>提供内置的高可用支持，部分 master 不可用时，还是可以继续工作的</li></ul><p>在 Redis cluster 架构下，每个 Redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号，比如 16379。<br />16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议， gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p><h1 id="2节点间通信机制"><a class="markdownIt-Anchor" href="#2节点间通信机制"></a> 2.节点间通信机制</h1><h2 id="基本通信机制"><a class="markdownIt-Anchor" href="#基本通信机制"></a> 基本通信机制</h2><p>集群元数据的维护有两种方式：</p><ul><li>集中式</li><li>Gossip 协议</li></ul><p>Redis cluster 节点间采用 gossip 协议进行通信。</p><h3 id="集中式"><a class="markdownIt-Anchor" href="#集中式"></a> 集中式</h3><p>集中式是将集群元数据（节点信息、故障等等）<strong>集中存储在某个节点上</strong>。集中式元数据集中存储的一个典型代表，就是大数据领域的 storm 。它是分布式的大数据实时计算引擎，是集中式的元数据存储的结构，底层基于 zookeeper（分布式协调的中间件）对所有元数据进行存储维护。<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659926419484-092f1a0b-98f3-4ee4-b07e-3b5f3a448a09.jpeg" alt="" /></p><h4 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h4><p>优点：</p><ul><li>元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到；</li></ul><p>缺点：</p><ul><li>所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。</li></ul><h3 id="gossip协议"><a class="markdownIt-Anchor" href="#gossip协议"></a> Gossip协议</h3><p>gossip 协议，<strong>所有节点都持有一份元数据</strong>，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659926906420-0a53a878-298f-49f3-bb74-d4dc1df011f7.jpeg" alt="" /></p><h4 id="优缺点-2"><a class="markdownIt-Anchor" href="#优缺点-2"></a> 优缺点</h4><p>优点：</p><ul><li>元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力</li></ul><p>缺点：</p><ul><li>元数据的更新有延时，可能导致集群中的一些操作会有一些滞后</li></ul><h1 id="3分布式选址算法"><a class="markdownIt-Anchor" href="#3分布式选址算法"></a> 3.分布式选址算法</h1><blockquote><p>既然Redis部署了多个Cluster，那么必然涉及访问哪一个节点的问题，即分布式选址。</p></blockquote><p>在动态变化的Cache环境中，判定哈希算法好坏的四个定义:</p><ul><li><strong>平衡性(Balance)</strong>: 平衡性是指哈希的结果能够尽可能分布到所有的分片中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</li><li><strong>单调性(Monotonicity)</strong>: 单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</li><li><strong>分散性(Spread)</strong>: 在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</li><li><strong>负载(Load)</strong>: 负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</li></ul><p>通常，有以下几种选址算法：</p><ul><li>hash 算法（大量缓存重建）</li><li>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</li><li>Redis cluster 的 hash slot 算法</li></ul><h2 id="hash算法"><a class="markdownIt-Anchor" href="#hash算法"></a> hash算法</h2><p>对一个key，先计算hash数值，然后对节点数目取模，随后拿这个结果去访问对应的master。</p><h3 id="局限性"><a class="markdownIt-Anchor" href="#局限性"></a> 局限性</h3><p>但是，当某个master挂掉后，节点数目就要改变，导致大量的请求无法获得正确有效的数据，甚至缓存有宕机风险。</p><h2 id="一致性hash算法"><a class="markdownIt-Anchor" href="#一致性hash算法"></a> 一致性hash算法</h2><blockquote><p>hash环解决单调性问题、虚拟节点解决不平衡问题。</p></blockquote><p>为了解决传统hash的单调性问题，一致性hash引入了hash环的概念：</p><h3 id="hash环"><a class="markdownIt-Anchor" href="#hash环"></a> hash环</h3><p>一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按<strong>顺时针方向</strong>组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。<br />来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，遇到的第一个 master 节点（顺时针第一个）就是 key 所在位置。<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659928825281-215bd784-2a8b-4291-b231-f6f867eb9f83.jpeg" alt="" /><br />在一致性哈希算法中，如果一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响。增加一个节点也同理。<br /><strong>不平衡问题：</strong><br />如果上图中master-2挂掉了，那么key-1、key-4、key-5都将打入master-3，造成缓存热点问题。<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659929026484-dac9cfb5-9d4d-4fe6-928b-1d34284318e4.jpeg" alt="" /></p><h3 id="虚拟节点"><a class="markdownIt-Anchor" href="#虚拟节点"></a> 虚拟节点</h3><p>为了解决这种热点问题，一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点。这样就实现了数据的均匀分布，负载均衡。<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659930218584-b3278b5f-5d05-4df5-a708-fac9fbd56020.jpeg" alt="" /><br />如果，master-3机器节点挂了，则：</p><ul><li>key-3映射到v-2-2，即master-2</li><li>key-4映射到v-1-1，即master-1</li></ul><p>某个节点宕机之后，存储及流量压力并没有全部转移到某台机器上，而是分散到了多台节点上。解决了节点宕机可能存在的雪崩问题。<br />当物理节点多的时候，虚拟节点多，这个的雪崩可能就越小。<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659930425265-99a801ac-ea1f-49e7-a3f7-59fc0a0caf19.jpeg" alt="" /></p><h2 id="redis-hash-slot算法"><a class="markdownIt-Anchor" href="#redis-hash-slot算法"></a> Redis hash slot算法</h2><p>Redis-cluster没有使用一致性hash，而是引入了哈希槽的概念。</p><ul><li>Redis-cluster中有<strong>16384</strong>(即2的14次方）个哈希槽，每个key通过<code>CRC16</code>校验后对16384取模来决定放置哪个槽。Cluster中的每个节点负责一部分hash槽（hash slot）。</li><li>Redis cluster 中每个 master 都会持有部分 slot，比如有 3 个 master，那么可能每个 master 持有 5000 多个 hash slot。</li><li>hash slot 让 node 的增加和移除很简单，增加一个 master，就将其他 master 的 hash slot 移动部分过去，减少一个 master，就将它的 hash slot 移动到其他 master 上去。移动 hash slot 的成本是非常低的。</li><li>客户端的 api，可以对指定的数据，让他们走同一个 hash slot，通过 <code>hash tag</code> 来实现。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659942231799-43eb1f7a-f221-410c-b152-c330d328a23a.jpeg" alt="" /><br />如果，master-2挂了，直接将master-2中的slot移动到master-1、master-3即可。</p><h3 id="为何16384"><a class="markdownIt-Anchor" href="#为何16384"></a> 为何16384?</h3><p><a href="https://github.com/redis/redis/issues/2576">https://github.com/redis/redis/issues/2576</a></p><blockquote><p>The reason is:</p><ol><li>Normal heartbeat packets carry the full configuration of a node, that can be replaced in an idempotent way with the old in order to update an old config. This means they contain the slots configuration for a node, in raw form, that uses 2k of space with16k slots, but would use a prohibitive 8k of space using 65k slots.</li><li>At the same time it is unlikely that Redis Cluster would scale to more than 1000 mater nodes because of other design tradeoffs.</li></ol></blockquote><p>So 16k was in the right range to ensure enough slots per master with a max of 1000 maters, but a small enough number to propagate the slot configuration as a raw bitmap easily. Note that in small clusters the bitmap would be hard to compress because when N is small the bitmap would have slots/N bits set that is a large percentage of bits set.</p><p>主要基于两点考虑：</p><ol><li><strong>消息大小</strong>考虑：尽管crc16能得到65535个值，但redis选择16384个slot，是因为16384的消息只占用了2k，而65535则需要8k。</li><li><strong>集群规模</strong>设计考虑：集群设计最多支持1000个分片，16384是相对比较好的选择，需要保证在最大集群规模下，slot均匀分布场景下，每个分片平均分到的slot不至于太小。</li></ol><p>需要注意2个问题：</p><ol><li>为什么要传全量的slot状态？<br />因为分布式场景，基于状态的设计更合理，状态的传播具有幂等性</li><li>为什么不考虑压缩？<br />集群规模较小的场景下，每个分片负责大量的slot，很难压缩。</li></ol><h1 id="4cluster高可用与主从切换"><a class="markdownIt-Anchor" href="#4cluster高可用与主从切换"></a> 4.Cluster高可用与主从切换</h1><blockquote><p>既然是集群，那master就会有宕机风险，如何检测？如何切换主从？<br />非常类似哨兵集群机制！</p></blockquote><h2 id="master宕机判断"><a class="markdownIt-Anchor" href="#master宕机判断"></a> master宕机判断</h2><ul><li>如果一个节点认为另外一个节点宕机，那么就是 pfail ，主观宕机。如果多个节点都认为另外一个节点宕机了，那么就是 fail ，客观宕机，跟哨兵的原理几乎一样，sdown，odown。</li><li>在 <code>cluster-node-timeout</code> 内，某个节点一直没有返回 pong ，那么就被认为 pfail 。</li><li>如果一个节点认为某个节点 pfail 了，那么会在 gossip ping 消息中， ping 给其他节点，如果超过半数的节点都认为 pfail 了，那么就会变成 fail</li></ul><h2 id="slave过滤"><a class="markdownIt-Anchor" href="#slave过滤"></a> slave过滤</h2><ul><li>对宕机的 master node，从其所有的 slave node 中，选择一个切换成 master node。</li><li>检查每个 slave node 与 master node 断开连接的时间，如果超过了 cluster-node-timeout * cluster-slave-validity-factor ，那么就没有资格切换成 master</li></ul><h2 id="slave选举"><a class="markdownIt-Anchor" href="#slave选举"></a> slave选举</h2><ul><li>每个从节点，都根据自己对 master 复制数据的 offset，来设置一个选举时间，offset 越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举。</li><li>所有的 master node 开始 slave 选举投票，给要进行选举的 slave 进行投票，如果大部分 master node （&gt;= N/2 + 1） 都投票给了某个从节点，那么选举通过，那个从节点可以切换成 master。</li><li>从节点执行主备切换，从节点切换为主节点。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分片</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis高可用-哨兵集群</title>
    <link href="/2022/08/08/Redis%E9%AB%98%E5%8F%AF%E7%94%A8-%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4/"/>
    <url>/2022/08/08/Redis%E9%AB%98%E5%8F%AF%E7%94%A8-%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="0-前言"><a class="markdownIt-Anchor" href="#0-前言"></a> 0. 前言</h1><p>除了主从复制，Redis另一种高可用方案是哨兵（sentinel）集群。</p><h2 id="哨兵"><a class="markdownIt-Anchor" href="#哨兵"></a> 哨兵</h2><p>sentinel，中文名是哨兵。哨兵是 Redis 集群架构中非常重要的一个组件，主要有以下功能：</p><ul><li><strong>集群监控</strong>：负责监控 Redis master 和 slave 进程是否正常工作；</li><li><strong>消息通知</strong>：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员；</li><li><strong>故障转移</strong>：如果 master node 挂掉了，会自动转移到 slave node 上；</li><li><strong>配置中心</strong>：如果故障转移发生了，通知 client 客户端新的 master 地址</li></ul><p>其核心功能是master节点的自动故障转移。<br />此外，哨兵用来保证Redis高可用，本身也是集群部署的，作为一个分布式系统，协同工作。<br />当然，会涉及到<strong>选举问题</strong>：<br />故障转移时，判断一个 master node 是否宕机了，需要大部分的哨兵都同意才行。<br /><strong>注意事项：</strong></p><ul><li>哨兵至少需要 3 个实例，来保证自己的健壮性</li><li>哨兵 + Redis 主从的部署架构，是不保证数据零丢失的，只能保证 Redis 集群的高可用性</li><li>对于哨兵 + Redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练</li></ul><h2 id="redis哨兵集群主从架构"><a class="markdownIt-Anchor" href="#redis哨兵集群主从架构"></a> Redis哨兵集群+主从架构</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659886866384-e5e52583-3a51-4cf8-a6f9-014fb8eb68e1.jpeg" alt="" /></p><h1 id="1哨兵集群组建"><a class="markdownIt-Anchor" href="#1哨兵集群组建"></a> 1.哨兵集群组建</h1><blockquote><p>哨兵集群如何组建？<br />基于Redis的Pub/Sub机制</p></blockquote><p>例如：<br />在主从集群中，主库上有一个名为<code>__sentinel__:hello</code>的频道，不同哨兵就是通过它来相互发现，实现互相通信的。在下图中，哨兵 1 把自己的 IP（172.16.19.3）和端口（26579）发布到<code>__sentinel__:hello</code>频道上，哨兵 2 和 3 订阅了该频道。那么此时，哨兵 2 和 3 就可以从这个频道直接获取哨兵 1 的 IP 地址和端口号。然后，哨兵 2、3 可以和哨兵 1 建立网络连接。<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659887028961-ddd53af1-647e-460f-bbf1-fe78b3a3e566.jpeg#clientId=u527f9151-2b34-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uafd6da26&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1535&amp;originWidth=2822&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=udaa4b0e1-fdaa-4a45-87ec-ae44fc95abd&amp;title=" alt="" /><br />通过这个方式，哨兵 2 和 3 也可以建立网络连接，这样一来，哨兵集群就形成了。它们相互间可以通过网络连接进行通信，比如说对主库有没有下线这件事儿进行判断和协商。</p><h1 id="2哨兵的监控功能"><a class="markdownIt-Anchor" href="#2哨兵的监控功能"></a> 2.哨兵的监控功能</h1><blockquote><p>哨兵监控什么？如何监控？<br />由哨兵向主库发送 INFO 命令来完成的</p></blockquote><p>哨兵 2 给主库发送 <code>INFO</code> 命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。哨兵 1 和 3 可以通过相同的方法和从库建立连接。<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659887158109-d96ede17-0672-4c18-abe5-4907d717180d.jpeg#clientId=u527f9151-2b34-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u4c0d1a6d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1404&amp;originWidth=2499&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uf62a9fe6-5fff-4ded-b85b-4ac35899be4&amp;title=" alt="" /></p><h1 id="3master下线判定"><a class="markdownIt-Anchor" href="#3master下线判定"></a> 3.master下线判定</h1><p>首先，有两个“下线”概念：</p><ul><li>主观下线（sdown）：任何一个哨兵都是可以监控探测，并作出master下线的判断</li><li>客观下线（odown）：由哨兵集群投票共同决定master是否下线</li></ul><p>具体地：<br />如果某个哨兵（如下图中的哨兵2）<code>ping</code>一个 master，超过了 <code>is-master-down-after-milliseconds</code> 指定的毫秒数之后，就主观认为 master 宕机了，即“主观下线”，就会给其他哨兵发送 <code>is-master-down-by-addr</code> 命令；<br />如果这个哨兵在指定时间内，收到了 <code>quorum</code>数量的其它哨兵也认为那个 master 是 sdown 的（投票），那么就认为是 odown 了，即“客观下线”<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659887409319-51f869e0-2d3e-4c23-adea-96b8e69343a0.jpeg#clientId=u527f9151-2b34-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u884d1199&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1260&amp;originWidth=2322&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u670d14b7-8575-4d7b-9bd0-76df8653404&amp;title=" alt="" /><br />如果赞成票数（这里是2）是大于等于哨兵配置文件中的 quorum 配置项（比如这里如果是quorum=2）, 则可以判定主库客观下线了。</p><h1 id="4哨兵集群选举"><a class="markdownIt-Anchor" href="#4哨兵集群选举"></a> 4.哨兵集群选举</h1><blockquote><p>判定master客观下线之后，由哪个哨兵节点执行主从切换？<br />通过选举。</p></blockquote><h2 id="为什么必然会出现选举共识机制"><a class="markdownIt-Anchor" href="#为什么必然会出现选举共识机制"></a> 为什么必然会出现选举/共识机制？</h2><p>为了避免哨兵的单点情况发生，所以需要一个哨兵的分布式集群。作为分布式集群，必然涉及共识问题（即选举问题）；同时故障的转移和通知都只需要一个主的哨兵节点就可以了。</p><h2 id="哨兵的选举机制是什么样的"><a class="markdownIt-Anchor" href="#哨兵的选举机制是什么样的"></a> 哨兵的选举机制是什么样的？</h2><p>哨兵的选举机制其实很简单，就是一个Raft选举算法： <strong>选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举</strong></p><h2 id="任何一个想成为-leader-的哨兵要满足两个条件"><a class="markdownIt-Anchor" href="#任何一个想成为-leader-的哨兵要满足两个条件"></a> 任何一个想成为 Leader 的哨兵，要满足两个条件：</h2><ul><li>第一，拿到半数以上的赞成票；</li><li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值</li></ul><h1 id="5新master的选举"><a class="markdownIt-Anchor" href="#5新master的选举"></a> 5.新master的选举</h1><blockquote><p>那么，可以开始主从切换了。选一个slave节点上位master</p></blockquote><h2 id="quorum-和-majority"><a class="markdownIt-Anchor" href="#quorum-和-majority"></a> quorum 和 majority</h2><p>每次一个哨兵要做主备切换，首先需要 quorum 数量的哨兵认为 odown，然后选举出一个哨兵来做切换，这个哨兵还需要得到 majority 哨兵的授权，才能正式执行切换。<br />如果 quorum &lt; majority，比如 5 个哨兵，majority 就是 3，quorum 设置为 2，那么就 3 个哨兵授权就可以执行切换。<br />但是如果 quorum &gt;= majority，那么必须 quorum 数量的哨兵都授权，比如 5 个哨兵，quorum 是 5，那么必须 5 个哨兵都同意授权，才能执行切换。</p><p>如果一个 master 被认为 odown 了，而且 <code>majority</code> 数量的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个 slave 来，会考虑 slave 的一些信息：</p><ul><li>跟 master 断开连接的时长</li><li>slave 优先级</li><li>复制 offset</li><li>run id</li></ul><h2 id="过滤掉不合适的slave"><a class="markdownIt-Anchor" href="#过滤掉不合适的slave"></a> 过滤掉不合适的slave</h2><p>如果一个 slave 跟 master 断开连接的时间已经超过了 <code>down-after-milliseconds</code> 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master</p><h2 id="对剩下的slave排序"><a class="markdownIt-Anchor" href="#对剩下的slave排序"></a> 对剩下的slave排序</h2><ul><li>按照 slave 优先级进行排序，slave priority 越低，优先级就越高。</li><li>如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。</li><li>如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。</li></ul><h1 id="6故障转移"><a class="markdownIt-Anchor" href="#6故障转移"></a> 6.故障转移</h1><blockquote><p>新的master选出来之后，就可以进行故障转移了</p></blockquote><p>假设：判断主库客观下线了，同时选出sentinel 3是哨兵leader。<br />将slave-1脱离原从节点（PS: 5.0 中应该是replicaof no one)，升级主节点， 将从节点slave-2指向新的主节点 通知客户端主节点已更换 将原主节点（oldMaster）变成从节点，指向新的主节点</p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659889986517-4e98c49f-7490-466c-b321-c2d3cef23bea.jpeg" alt="" /><br /><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-sentinel.html"><br /></a></p><ul><li>将slave-1脱离原从节点（PS: 5.0 中应该是<code>replicaof no one</code>)，升级为主节点</li><li>将从节点slave-2指向新的主节点</li><li>通知客户端主节点已更换</li><li>将原主节点（oldMaster）变成从节点，指向新的主节点</li></ul><p>转移过后：<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659889857469-1dff90fd-11b2-4596-bb58-71c1da4d229a.jpeg" alt="" /></p><h1 id="数据丢失问题"><a class="markdownIt-Anchor" href="#数据丢失问题"></a> 数据丢失问题？</h1><h2 id="异步复制导致的丢失"><a class="markdownIt-Anchor" href="#异步复制导致的丢失"></a> 异步复制导致的丢失</h2><p>因为 master-&gt;slave 的复制是异步的，所以可能有部分数据还没复制到 slave，master 就宕机了，此时这部分数据就丢失了</p><h2 id="脑裂导致的数据丢失"><a class="markdownIt-Anchor" href="#脑裂导致的数据丢失"></a> 脑裂导致的数据丢失</h2><p>脑裂，也就是说，某个 master 所在机器突然脱离了正常的网络，跟其他 slave 机器不能连接，但是实际上 master 还运行着。此时哨兵可能就会认为 master 宕机了，然后开启选举，将其他 slave 切换成了 master。这个时候，**集群里就会有两个 master **，也就是所谓的脑裂。<br />此时虽然某个 slave 被切换成了 master，但是可能 client 还没来得及切换到新的 master，还继续向旧 master 写数据。因此旧 master 再次恢复的时候，会被作为一个 slave 挂到新的 master 上去，自己的数据会清空，重新从新的 master 复制数据。而新的 master 并没有后来 client 写入的数据，因此，这部分数据也就丢失了。</p><h2 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案"></a> 解决方案</h2><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">min-slaves-to-write 1&#x2F;&#x2F; 要求至少有 1 个 slavemin-slaves-max-lag 10&#x2F;&#x2F; 数据复制和同步的延迟不能超过 10 秒<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>有了 <code>min-slaves-max-lag</code> 这个配置，就可以确保，一旦 slave 复制数据和 ack 延时太长，就认为可能 master 宕机后损失的数据太多了，那么就拒绝写请求，这样可以把 master 宕机时由于部分数据未同步到 slave 导致的数据丢失降低的可控范围内。<br />如果一个 master 出现了脑裂，跟其他 slave 丢了连接，那么上面两个配置可以确保，如果不能继续给指定数量的 slave 发送数据，而且 slave 超过 10 秒没有给自己 ack 消息，那么就直接拒绝客户端的写请求。因此在脑裂场景下，最多就丢失 10 秒的数据。</p><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><ul><li><a href="https://doocs.github.io/advanced-java/#/docs/high-concurrency/redis-sentinel">https://doocs.github.io/advanced-java/#/docs/high-concurrency/redis-sentinel</a></li><li><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-sentinel.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-sentinel.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哨兵</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis高可用-主从复制</title>
    <link href="/2022/08/07/Redis%E9%AB%98%E5%8F%AF%E7%94%A8-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <url>/2022/08/07/Redis%E9%AB%98%E5%8F%AF%E7%94%A8-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="0前言"><a class="markdownIt-Anchor" href="#0前言"></a> 0.前言</h1><h2 id="如何保证redis高可用"><a class="markdownIt-Anchor" href="#如何保证redis高可用"></a> 如何保证Redis高可用？</h2><p>高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计<strong>减少系统不能提供服务的时间</strong>（比如server宕机、网络断联等）。<br />Redis主要提供一主多从下的主从复制和哨兵集群机制保证高可用。</p><h2 id="redis主从架构"><a class="markdownIt-Anchor" href="#redis主从架构"></a> Redis主从架构</h2><p>单机的 Redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。<br />因此架构做成主从(master-slave)架构，<strong>一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读</strong>。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659797238827-959ffbe3-7fcb-4b35-bf68-d392c43383aa.jpeg" alt="" /></p><h2 id="读写分离"><a class="markdownIt-Anchor" href="#读写分离"></a> 读写分离</h2><p>读操作：主库、从库都可以接收；<br />写操作：首先到主库执行，然后，主库将写操作同步给从库</p><h2 id="主从复制"><a class="markdownIt-Anchor" href="#主从复制"></a> 主从复制</h2><blockquote><p>主从复制，是将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)。<br />数据的复制是单向的，只能由主节点到从节点。</p></blockquote><h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3><ul><li><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式</li><li><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余</li><li><strong>负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量</li><li><strong>高可用基石</strong>：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础</li></ul><h1 id="1主从复制实现原理"><a class="markdownIt-Anchor" href="#1主从复制实现原理"></a> 1.主从复制实现原理</h1><blockquote><p>Redis在V2.8之前仅支持全量复制</p></blockquote><ul><li>全量（同步）复制：比如在第一次同步时</li><li>增量（同步）复制：只会把主从库网络断连期间主库收到的命令，同步给从库</li></ul><h2 id="全量复制"><a class="markdownIt-Anchor" href="#全量复制"></a> 全量复制</h2><h3 id="大致过程"><a class="markdownIt-Anchor" href="#大致过程"></a> 大致过程</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659797918729-0d449448-56f4-4fdd-aad3-5de9023ba48f.jpeg" alt="" /></p><h3 id="具体过程"><a class="markdownIt-Anchor" href="#具体过程"></a> 具体过程</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659799559978-6b827237-2581-487b-bbf6-f3f3eaf49a2b.jpeg" alt="" /></p><p><strong>第一阶段</strong>：<br />主从库间建立连接、协商同步，主要是为全量复制做准备。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。<br />具体来说，从库给主库发送 PSYNC 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。PSYNC 命令包含了主库的 runID 和复制进度 offset 两个参数：</p><ul><li>runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”；</li><li>offset，此时设为 -1，表示第一次复制。</li></ul><p>主库收到 PSYNC 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。这里有个地方需要注意，FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库。<br /><strong>第二阶段</strong>：<br />主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。<br />具体来说，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。<br /><strong>第三阶段</strong>：<br />主库会把第二阶段执行过程中新收到的写命令，再发送给从库。<br />具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</p><h2 id="增量复制"><a class="markdownIt-Anchor" href="#增量复制"></a> 增量复制</h2><blockquote><p>Redis在2.8引入了增量复制</p></blockquote><h3 id="为何引入增量复制"><a class="markdownIt-Anchor" href="#为何引入增量复制"></a> 为何引入增量复制？</h3><p>断点续传。<br />如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659800739355-112ea4b4-967c-4abf-b0c0-acd1368b90b2.jpeg" alt="" /></p><h3 id="两个缓冲区"><a class="markdownIt-Anchor" href="#两个缓冲区"></a> 两个缓冲区</h3><p><strong>repl_backlog_buffer</strong>：<br />它是为了从库断开之后，如何找到主从差异数据而设计的环形缓冲区，从而避免全量复制带来的性能开销。如果从库断开时间太久，repl_backlog_buffer环形缓冲区被主库的写命令覆盖了，那么从库连上主库后只能乖乖地进行一次全量复制，所以repl_backlog_buffer配置尽量大一些，可以降低主从断开后全量复制的概率。<br />而在repl_backlog_buffer中找主从差异的数据后，如何发给从库呢？这就用到了replication buffer。<br /><strong>replication buffer：</strong><br />Redis和客户端通信也好，和从库通信也好，Redis都需要给分配一个 内存buffer进行数据交互，客户端是一个client，从库也是一个client，我们每个client连上Redis后，Redis都会分配一个client buffer，所有数据交互都是通过这个buffer进行的：Redis先把数据写到这个buffer中，然后再把buffer中的数据发到client socket中再通过网络发送出去，这样就完成了数据交互。<br />所以主从在增量同步时，从库作为一个client，也会分配一个buffer，只不过这个buffer专门用来传播用户的写命令到从库，保证主从数据一致，我们通常把它叫做replication buffer</p><h1 id="2几点总结"><a class="markdownIt-Anchor" href="#2几点总结"></a> 2.几点总结</h1><h2 id="核心机制"><a class="markdownIt-Anchor" href="#核心机制"></a> 核心机制</h2><ul><li>Redis 采用异步方式复制数据到 slave 节点，不过 Redis2.8 开始，slave node 会周期性地确认自己每次复制的数据量；</li><li>一个 master node 是可以配置多个 slave node 的；</li><li>slave node 也可以连接其他的 slave node；</li><li>slave node 做复制的时候，不会 block master node 的正常工作；</li><li>slave node 在做复制的时候，也不会 block 对自己的查询操作，它会用旧的数据集来提供服务；但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了；</li><li>slave node 主要用来进行横向扩容，做读写分离，扩容的 slave node 可以提高读的吞吐量。</li></ul><h2 id="无磁盘复制"><a class="markdownIt-Anchor" href="#无磁盘复制"></a> 无磁盘复制</h2><p>Redis 默认是磁盘复制，但是如果使用比较低速的磁盘，这种操作会给主服务器带来较大的压力。Redis从2.8.18版本开始尝试支持无磁盘的复制。使用这种设置时，子进程直接将RDB通过网络发送给从服务器，不使用磁盘作为中间存储。<br />master创建一个新进程直接dump RDB到slave的socket，不经过主进程，不经过硬盘。适用于disk较慢，并且网络较快的时候。</p><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">repl-diskless-sync yes# 等待 5s 后再开始复制，因为要等更多 slave 重新连接过来repl-diskless-sync-delay 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="为何全量复制用的rdb"><a class="markdownIt-Anchor" href="#为何全量复制用的rdb"></a> 为何全量复制用的RDB？</h2><ul><li>RDB文件内容是经过压缩的二进制数据（不同数据类型数据做了针对性优化），<strong>文件很小</strong>；而AOF文件记录的是每一次写操作的命令，写操作越多文件会变得很大，其中还包括很多对同一个key的多次冗余操作。</li><li>在主从全量数据同步时，传输RDB文件可以尽量降低对主库机器网络带宽的消耗，从库在加载RDB文件时，一是文件小，读取整个文件的速度会很快，二是因为RDB文件存储的都是二进制数据，从库直接按照RDB协议解析还原数据即可，速度会非常快；而AOF需要依次重放每个写命令，这个过程会经历冗长的处理逻辑，恢复速度相比RDB会慢得多，所以使用RDB进行主从全量复制的成本最低。</li><li>要使用AOF做全量复制，意味着必须打开AOF功能，打开AOF就要选择文件刷盘的策略，选择不当会严重影响Redis性能；而RDB只有在需要定时备份和主从全量复制数据时才会触发生成一次快照。</li></ul><h2 id="key过期处理"><a class="markdownIt-Anchor" href="#key过期处理"></a> key过期处理？</h2><p>slave 不会过期 key，只会等待 master 过期 key。<br />如果 master 过期了一个 key，或者通过 LRU 淘汰了一个 key，那么会模拟一条 del 命令发送给 slave。</p><h2 id="读写分离带来的问题"><a class="markdownIt-Anchor" href="#读写分离带来的问题"></a> 读写分离带来的问题</h2><h3 id="数据不一致问题"><a class="markdownIt-Anchor" href="#数据不一致问题"></a> 数据不一致问题</h3><p>由于主从复制的命令传播是异步的，延迟与数据的不一致不可避免。如果应用对数据不一致的接受程度程度较低，可能的优化措施包括：</p><ul><li>优化主从节点之间的网络环境（如在同机房部署）；</li><li>监控主从节点延迟（通过offset）判断，如果从节点延迟过大，通知应用不再通过该从节点读取数据；</li><li>使用集群同时扩展写负载和读负载等</li></ul><h3 id="数据过期问题"><a class="markdownIt-Anchor" href="#数据过期问题"></a> 数据过期问题</h3><p>slave不会主动删除和淘汰过期的key，它只会等待master去处理。但是，如果master在定期删除+惰性删除+内存淘汰机制下，仍然没有处理到某些过期的key，那么这些过期的key在slave中会一直存在，此时clien读到的key就是过期的。</p><blockquote><p>Redis 3.2解决了数据过期问题。</p></blockquote><h3 id="故障切换问题"><a class="markdownIt-Anchor" href="#故障切换问题"></a> 故障切换问题</h3><p>在没有使用哨兵的读写分离场景下，应用针对读和写分别连接不同的Redis节点；当主节点或从节点出现问题而发生更改时，需要及时修改应用程序读写Redis数据的连接；连接的切换可以手动进行，或者自己写监控程序进行切换，但前者响应慢、容易出错，后者实现复杂，成本都不算低</p><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><ul><li><a href="https://redis.io/docs/manual/replication/">https://redis.io/docs/manual/replication/</a></li><li>《Redis设计与实现》</li><li><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-copy.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-copy.html</a></li><li><a href="https://doocs.github.io/advanced-java/#/docs/high-concurrency/redis-master-slave">https://doocs.github.io/advanced-java/#/docs/high-concurrency/redis-master-slave</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>主从复制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis过期策略和内存淘汰机制</title>
    <link href="/2022/08/06/Redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/08/06/Redis%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="0前言"><a class="markdownIt-Anchor" href="#0前言"></a> 0.前言</h1><p>既然Redis是内存缓存，那由于内存容量有限，不可能像文件DB那样把数据仍进去就完事了。<br />并且Redis里存放的多是热点数据，所以需要适时对过期的key进行清理，来释放空间；但是，在清理过后，仍然有可能还是存在大量的“废弃”key，这时候就需要内存淘汰机制来强制清理了。</p><h2 id="过期时间"><a class="markdownIt-Anchor" href="#过期时间"></a> 过期时间</h2><p>Redis支持为key设置一个生存时间TTL，在经过指定的时间后，Server会自动删除TTL=0的key。</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redis<span class="token operator">></span> SET key valueOKredis<span class="token operator">></span> EXPIRE key <span class="token number">5</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>redis<span class="token operator">></span> GET key  // <span class="token number">5</span>秒之内<span class="token string">"value"</span>redis<span class="token operator">></span> GET key  // <span class="token number">5</span>秒之后<span class="token punctuation">(</span>nil<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><blockquote><p>SETEX命令可以在设置一个字符串键的同时为键设置过期时间，这个命令是一个类型限定的命令（只能用于字符串键）。<br />同时Redis提供了统一的设置过期时间命令：EXPIRE，PEXPIRE为一个key设置秒，毫秒级别的TTL</p></blockquote><h2 id="可能的过期策略"><a class="markdownIt-Anchor" href="#可能的过期策略"></a> 可能的过期策略</h2><ul><li>定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作</li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键</li><li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定</li></ul><p>定期删除是定时+惰性的折中。</p><h1 id="1redis过期策略"><a class="markdownIt-Anchor" href="#1redis过期策略"></a> 1.Redis过期策略</h1><p>Redis提供了以下两种过期策略：<br />定期删除+惰性删除</p><h2 id="定期删除"><a class="markdownIt-Anchor" href="#定期删除"></a> 定期删除</h2><p>Redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。</p><h3 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h3><p>优点：</p><ul><li>通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响</li><li>减少内存浪费</li></ul><p>缺点：</p><ul><li>有的key可能扫描不到</li></ul><p><strong>为毛随机抽取？</strong><br />如果全部抽取，则需要扫描所有的key，判断TTL，开销太大！<br /><strong>有何不足？</strong><br />随机抽取，可能导致大量的过期key没有被抽取到！</p><h2 id="惰性删除"><a class="markdownIt-Anchor" href="#惰性删除"></a> 惰性删除</h2><p>获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。</p><h3 id="优缺点-2"><a class="markdownIt-Anchor" href="#优缺点-2"></a> 优缺点</h3><p>优点：</p><ul><li>对CPU时间来说是最友好的：程序只会在取出键时才对键进行过期检查，这可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会在删除其他无关的过期键上花费任何CPU时间。</li></ul><p>缺点：</p><ul><li>它对内存是最不友好的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放</li><li>内存泄漏：如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除（除非用户手动执行FLUSHDB）</li></ul><h1 id="2内存淘汰算法"><a class="markdownIt-Anchor" href="#2内存淘汰算法"></a> 2.内存淘汰算法</h1><h2 id="定期删除惰性删除就一定ok"><a class="markdownIt-Anchor" href="#定期删除惰性删除就一定ok"></a> 定期删除+惰性删除就一定OK？</h2><p>如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期 key 堆积在内存里，导致 Redis 内存块耗尽了，咋整？<br />答案是：内存淘汰机制。</p><h2 id="几种淘汰算法"><a class="markdownIt-Anchor" href="#几种淘汰算法"></a> 几种淘汰算法</h2><ul><li><strong>noeviction</strong>:  当内存不足以容纳新写入数据时，新写入操作会报错</li><li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li><li><strong>allkeys-random</strong>：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key</li><li><strong>volatile-lru</strong>：当内存不足以容纳新写入数据时，<strong>在设置了过期时间的键空间中</strong>，移除最近最少使用的 key（这个一般不太合适）</li><li><strong>volatile-random</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。</li><li><strong>volatile-ttl</strong>：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除</li></ul><h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2><p>redis.conf里配置<code>maxmemory</code>，表示使用最大的内存。<br />64位机器上，默认是0，表示没有内存限制；32位机器上，默认是3GB</p><h2 id="手撕一个lrulfu"><a class="markdownIt-Anchor" href="#手撕一个lrulfu"></a> 手撕一个LRU/LFU？</h2><h3 id="linkedhashmap"><a class="markdownIt-Anchor" href="#linkedhashmap"></a> LinkedHashMap</h3><p>最简单的，使用LinkedHashMap</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">super</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">></span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> capacity<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h3 id="手撕双链表"><a class="markdownIt-Anchor" href="#手撕双链表"></a> 手撕双链表</h3><p><a href="https://www.yuque.com/mokeeqian/awaresome-backend/kgrgu8?view=doc_embed">缓存淘汰算法LRU/LFU实现</a></p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LRU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis持久化</title>
    <link href="/2022/08/05/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2022/08/05/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="0前言"><a class="markdownIt-Anchor" href="#0前言"></a> 0.前言</h1><blockquote><p>持久化是指将数据写入持久存储，例如固态磁盘 (SSD)。Redis支持以下几种持久化方式：</p><ul><li>RDB（Redis DataBase）：以指定的时间间隔执行数据集的时间点快照</li><li>AOF（Append Only File）：记录server收到的每个写操作命令，在重新启动时，再次执行这些命令来重建数据</li><li>RDB+AOF：重启后，AOF用于重建数据</li></ul></blockquote><h2 id="为何要持久化"><a class="markdownIt-Anchor" href="#为何要持久化"></a> 为何要持久化？</h2><ul><li>数据放在内存，容量有限、断电丢失</li></ul><h1 id="1rdb"><a class="markdownIt-Anchor" href="#1rdb"></a> 1.RDB</h1><p>Redis将内存数据快照写入rdb后缀的二进制文件中，这叫snapshot。</p><h2 id="触发方式"><a class="markdownIt-Anchor" href="#触发方式"></a> 触发方式</h2><p>redis RDB持久化有两种触发方式：</p><ul><li>手动触发：使用<code>SAVE</code>或<code>BGSAVE</code>命令</li><li>自动触发：比如每隔N秒，如果数据有M个改动</li></ul><h3 id="手动触发"><a class="markdownIt-Anchor" href="#手动触发"></a> 手动触发</h3><ul><li>save：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存 比较大的实例会造成长时间<strong>阻塞</strong>，线上环境不建议使用</li><li>bgsave：fork创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659588393639-11cb9146-cb2a-4907-9b0a-473d9a880e1a.jpeg" alt="" /></p><h3 id="自动触发"><a class="markdownIt-Anchor" href="#自动触发"></a> 自动触发</h3><p>以下四种情况会自动触发：</p><ul><li>redis.conf中设置了<code>save m n</code>，即每隔m秒检查数据是否有n次改动</li><li>主从复制时，从节点要从主节点进行全量复制时也会触发bgsave操作，生成当时的快照发送到从节点</li><li>执行debug reload命令重新加载redis时也会触发bgsave操作</li><li>默认情况下执行shutdown命令时，如果没有开启aof持久化，那么也会触发bgsave操作</li></ul><h2 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h2><p>优点：</p><ul><li>RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景</li><li>RDB加载RDB文件恢复数据比AOF快</li></ul><p>缺点：</p><ul><li>实时性不够，无法做到秒级的持久化</li><li>每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高</li><li>RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全</li></ul><h1 id="2aof"><a class="markdownIt-Anchor" href="#2aof"></a> 2.AOF</h1><blockquote><p>Redis是“写后”日志，Redis先执行命令，把数据写入内存，然后才记录日志。日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存。<br />PS: 大多数的数据库采用的是写前日志（WAL），例如MySQL，通过写前日志和两阶段提交，实现数据和逻辑的一致性。</p></blockquote><h2 id="写后日志"><a class="markdownIt-Anchor" href="#写后日志"></a> 写后日志</h2><p>优点：</p><ul><li>避免额外检查开销：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错</li><li>不会阻塞当前写操作</li></ul><p>缺点：</p><ul><li>数据丢失</li><li>主线程写磁盘压力大</li></ul><h2 id="aof的实现"><a class="markdownIt-Anchor" href="#aof的实现"></a> AOF的实现</h2><p>AOF实现分为三个阶段：<strong>命令追加、文件写入、文件同步</strong><br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659587578748-672bbcce-16f5-402d-a03c-c40490891130.jpeg" alt="" /></p><h3 id="命令追加"><a class="markdownIt-Anchor" href="#命令追加"></a> 命令追加</h3><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以<strong>协议格式</strong>将被执行的写命令追加到服务器状态的<strong>aof_buf缓冲区</strong>的末尾：</p><div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// ...</span>    <span class="token comment">// AOF</span>缓冲区    sds aof_buf<span class="token punctuation">;</span>    <span class="token comment">// ...</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p>例如：<br />执行如下操作：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">redis<span class="token operator">></span> SET KEY VALUEOK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>那么服务器在执行这个SET命令之后，会将以下协议内容追加到aof_buf缓冲区的末尾：</p><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">*3<span class="token punctuation">\</span>r<span class="token punctuation">\</span>n<span class="token variable">$3</span><span class="token punctuation">\</span>r<span class="token punctuation">\</span>nSET<span class="token punctuation">\</span>r<span class="token punctuation">\</span>n<span class="token variable">$3</span><span class="token punctuation">\</span>r<span class="token punctuation">\</span>nKEY<span class="token punctuation">\</span>r<span class="token punctuation">\</span>n<span class="token variable">$5</span><span class="token punctuation">\</span>r<span class="token punctuation">\</span>nVALUE<span class="token punctuation">\</span>r<span class="token punctuation">\</span>n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><h3 id="文件写入和同步"><a class="markdownIt-Anchor" href="#文件写入和同步"></a> 文件写入和同步</h3><p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到aof_buf缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用flushAppendOnlyFile函数，<strong>考虑是否需要将aof_buf缓冲区中的内容写入和保存到AOF文件里面。</strong><br />关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659534013380-802831cd-a08e-4c78-96ad-a5c55aace518.jpeg#clientId=u22aea455-8f94-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u7e5a6d59&amp;margin=%5Bobject%20Object%5D&amp;originHeight=682&amp;originWidth=2284&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;status=done&amp;style=none&amp;taskId=ud98a5241-a80f-43ca-b630-5924cd9fdf0&amp;title=%E4%B8%8D%E5%90%8Cappendfsync%E5%80%BC%E4%BA%A7%E7%94%9F%E4%B8%8D%E5%90%8C%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E8%A1%8C%E4%B8%BA" alt="不同appendfsync值产生不同的持久化行为" title="不同appendfsync值产生不同的持久化行为" /></p><ul><li>Always：每个写命令执行完，立马同步地将日志写回磁盘</li><li>Everysec：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘</li><li>No：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</li></ul><p>为了提高文件的写入效率，在现代操作系统中，当用户调用write函数，将一些数据写入到文件的时候，操作系统通常会将写入数据暂时保存在一个内存缓冲区里面，等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正地将缓冲区中的数据写入到磁盘里面。<br />这种做法虽然提高了效率，但也为写入数据带来了安全问题，因为如果计算机发生停机，那么保存在内存缓冲区里面的写入数据将会丢失。<br />为此，系统提供了fsync和fdatasync两个同步函数，它们<strong>可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性</strong>。</p><h2 id="aof文件载入和数据还原"><a class="markdownIt-Anchor" href="#aof文件载入和数据还原"></a> AOF文件载入和数据还原</h2><p>载入：<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659588845176-67baafb5-fd4e-44d0-ba70-a7eca971cac1.jpeg" alt="" /></p><h2 id="aof重写"><a class="markdownIt-Anchor" href="#aof重写"></a> AOF重写</h2><p>随着服务器运行时间的流逝，AOF文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过大的AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多。<br />为了解决AOF文件体积膨胀的问题，Redis提供了**AOF文件重写（rewrite）**功能。<br />通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件不会包含任何浪费空间的冗余命令，所以新AOF文件的体积通常会比旧AOF文件的体积要小得多。<br /><strong>AOF重写通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作</strong><br />举个例子：<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659535493275-500ebe16-d75a-4443-a5a3-3d850bceb7f3.jpeg#clientId=u22aea455-8f94-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u9ae807bf&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1080&amp;originWidth=3970&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u868f368b-8f59-4e8b-9ca2-038de49b617&amp;title=" alt="" /></p><h4 id="执行过程"><a class="markdownIt-Anchor" href="#执行过程"></a> 执行过程</h4><ul><li>主线程fork出子进程重写aof日志</li><li>子进程重写日志完成后，主线程追加aof日志缓冲</li><li>替换日志文件</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659589676311-9267e880-4d33-4a35-884a-a665d16ab340.jpeg#clientId=u22aea455-8f94-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=338&amp;id=uf645d607&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1080&amp;originWidth=2308&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;status=done&amp;style=none&amp;taskId=uad606050-7696-49ad-a51f-331b77f1107&amp;title=AOF%E9%87%8D%E5%86%99%E8%BF%87%E7%A8%8B&amp;width=723.0000610351562" alt="AOF重写过程" title="AOF重写过程" /><br />在执行BGREWRITEAOF命令时，Redis服务器会维护一个AOF重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作</p><h4 id="几个问题"><a class="markdownIt-Anchor" href="#几个问题"></a> 几个问题</h4><h5 id="aof重写会阻塞吗"><a class="markdownIt-Anchor" href="#aof重写会阻塞吗"></a> AOF重写会阻塞吗？</h5><p>AOF重写过程是由后台进程bgrewriteaof来完成的。主线程fork出后台的bgrewriteaof子进程，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。<br />所以aof在重写时，在fork进程时是会阻塞住主线程的。</p><h5 id="aof日志何时会重写"><a class="markdownIt-Anchor" href="#aof日志何时会重写"></a> AOF日志何时会重写？</h5><p>有两个配置项控制AOF重写的触发：</p><ul><li>auto-aof-rewrite-min-size:表示运行AOF重写时文件的最小大小，默认为64MB。</li><li>auto-aof-rewrite-percentage:这个值的计算方式是，当前aof文件大小和上一次重写后aof文件大小的差值，再除以上一次重写后aof文件大小。也就是当前aof文件比上一次重写后aof文件的增量大小，和上一次重写后aof文件大小的比值</li></ul><h5 id="为何不复用旧的aof文件"><a class="markdownIt-Anchor" href="#为何不复用旧的aof文件"></a> 为何不复用旧的AOF文件？</h5><ul><li>父子进程同时写同一个文件，涉及资源竞争问题</li><li>如果AOF重写失败，则会导致原AOF文件内容丢失</li></ul><h2 id="优缺点-2"><a class="markdownIt-Anchor" href="#优缺点-2"></a> 优缺点</h2><p>优点：</p><ul><li>灵活配置，提供三种文件写入和同步策略</li><li>AOF文件是只读的，不存在断电文件指针丢失问题</li><li>当AOF文件过大时，支持后台自动重写AOF文件，该过程不会导致数据丢失</li><li>AOF文件保存了Redis写命令，可读性强</li></ul><p>缺点：</p><ul><li>相同情况下，AOF文件大小要比RDB文件大</li><li>AOF执行过程要比RDB慢，取决于不同的<code>fsync</code>策略</li></ul><h1 id="3从持久化数据中恢复数据"><a class="markdownIt-Anchor" href="#3从持久化数据中恢复数据"></a> 3.从持久化数据中恢复数据</h1><p>数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？</p><ul><li>优先加载AOF</li><li>其次才是RDB</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659589558800-241b111b-ef95-4c21-980d-dde4737a8616.jpeg" alt="" /></p><h1 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h1><ul><li>《Redis设计与实现》</li><li><a href="https://redis.io/docs/manual/">https://redis.io/docs/manual/</a></li><li><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AOF</tag>
      
      <tag>RDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>InnoDB存储引擎中的索引</title>
    <link href="/2022/08/01/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/08/01/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="0-前言"><a class="markdownIt-Anchor" href="#0-前言"></a> 0. 前言</h1><p>在InnoDB存储引擎中，表都是根据主键顺序组织存放的，这种存储方式的表称为<strong>索引组织表</strong>（index organized table）。<br />在InnoDB存储引擎表中，每张表都有个主键（Primary Key），如果在创建表时没有显式地定义主键，则InnoDB存储引擎会按如下方式选择或创建主键：</p><ul><li>首先判断表中是否有<strong>非空的唯一索引</strong>（Unique NOT NULL），如果有，则该列即为主键（如果有多个，则选取<strong>定义索引顺序的第一个</strong>，而不是定义列的顺序）</li><li>如果不符合上述条件，InnoDB存储引擎自动创建一个6字节大小的指针</li></ul><h1 id="1innodb索引分类"><a class="markdownIt-Anchor" href="#1innodb索引分类"></a> 1.InnoDB索引分类</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659351643476-d531b370-5d15-46ae-b1e0-444befcf3219.jpeg" alt="" /></p><h1 id="2b树索引"><a class="markdownIt-Anchor" href="#2b树索引"></a> 2.B+树索引</h1><h2 id="21聚集索引"><a class="markdownIt-Anchor" href="#21聚集索引"></a> 2.1聚集索引</h2><p>聚集索引，又叫<strong>主键索引</strong>，按照每张表的主键构建一颗B+树，一个索引就是一颗B+树，叶子节点（数据页）存放整张表的行记录数据。</p><h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3><ul><li>聚集索引的存储并不是物理上连续，而是逻辑上连续<ul><li>页通过双向链表链接，页按照主键的顺序排序</li><li>每个页中的记录也是通过双向链表进行维护的</li></ul></li><li>由于实际的数据页只能按照一棵B+树进行排序，因此<strong>每张表只能拥有一个聚集索引</strong>。</li><li>在多数情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子节点上直接找到数据</li><li>此外，由于定义了数据的逻辑顺序，聚集索引能够特别快地访问针对<strong>范围值的查询和排序</strong>。</li></ul><h2 id="22非聚集索引"><a class="markdownIt-Anchor" href="#22非聚集索引"></a> 2.2非聚集索引</h2><p>辅助索引（Secondary Index，也称非聚集索引），叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含了一个书签（bookmark）。该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。由于InnoDB存储引擎表是索引组织表，因此InnoDB存储引擎的辅助索引的书签就是相应行数据的<strong>聚集索引键</strong></p><h3 id="特点-2"><a class="markdownIt-Anchor" href="#特点-2"></a> 特点</h3><ul><li>辅助索引的存在并不影响数据在聚集索引中的组织，因此<strong>每张表上可以有多个辅助索引</strong></li></ul><h3 id="查找过程"><a class="markdownIt-Anchor" href="#查找过程"></a> 查找过程</h3><p>查找一个非聚集索引，InnoDB引擎首先会遍历非聚集索引B+树，通过页级别的 指针找到指向聚集索引的键ID，然后通过这个ID键再去查找聚集索引，得到一个完整的行数据，这个过程叫做<strong>回表</strong>。<br />例子：</p><ul><li>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</li><li>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次</li></ul><h1 id="3索引维护"><a class="markdownIt-Anchor" href="#3索引维护"></a> 3.索引维护</h1><p>在插入新纪录、删除旧纪录时，B+ 树为了维护索引有序性，会涉及到索引的维护问题。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/29351684/1659343760942-7134bf0c-ac1b-4452-86de-f10b92d18198.png#clientId=uc2bce005-9626-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=450&amp;id=u0e0ffe97&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=856&amp;originWidth=1142&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=169686&amp;status=done&amp;style=none&amp;taskId=u336d4bf8-f074-4b19-9eae-081b66a42b7&amp;title=%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95&amp;width=601" alt="image.png" title="聚集索引和非聚集索引" /></p><ul><li>如果 在上图中插入<code>ID=700</code>的记录，则在R5后面插入一条新记录就行；</li><li>如果插入<code>ID=400</code>的记录，则需要移动R4，R5，然后把ID=400插进去；更糟糕的，如果R4所在的页满了，就需要申请新的页，挪动部分数据到新页上面（<strong>页分裂</strong>）</li></ul><p>注意：</p><ul><li>页分裂会降低空间利用率、性能</li><li>主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小</li></ul><h1 id="4索引应用"><a class="markdownIt-Anchor" href="#4索引应用"></a> 4.索引应用</h1><h2 id="41联合索引"><a class="markdownIt-Anchor" href="#41联合索引"></a> 4.1联合索引</h2><p>联合索引是指对表上的多个列进行索引</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> t<span class="token punctuation">(</span>a <span class="token keyword">INT</span><span class="token punctuation">,</span>b <span class="token keyword">INT</span><span class="token punctuation">,</span><span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">KEY</span> idx_a_b<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">INNODB</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29351684/1659344528829-ccd7baaa-9f81-4f14-8f59-5ffff518efe0.png#clientId=uc2bce005-9626-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=191&amp;id=u9ec55153&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=335&amp;originWidth=986&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=69496&amp;status=done&amp;style=none&amp;taskId=u7e86ae48-1cd6-4207-bf9d-9d60b18cebb&amp;title=%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95&amp;width=563.4285714285714" alt="image.png" title="联合索引" /><br />显然，(a, b)的联合索引，也是按照(a, b)排序来存放的。</p><h3 id="最左前缀匹配原则"><a class="markdownIt-Anchor" href="#最左前缀匹配原则"></a> 最左前缀匹配原则</h3><p>联合索引中，如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配。<br />这个最左前缀可以是：</p><ul><li>联合索引的最左 N 个字段；</li><li>也可以是字符串索引的最左 M 个字符</li></ul><p>例如：</p><ul><li>SELECT*FROM TABLE WHERE a=xxx and b=xxx，显可以使用（a，b）这个联合索引的</li><li>SELECT*FROM TABLE WHERE a=xxx，也可以使用这个（a，b）索引</li><li>SELECT*FROM TABLE WHERE b=xxx，则<strong>不可以</strong>使用这棵B+树索引</li></ul><p>那么，如果非要查询b，怎么办？</p><h3 id="如果安排联合索引顺序"><a class="markdownIt-Anchor" href="#如果安排联合索引顺序"></a> 如果安排联合索引顺序？</h3><p>考虑索引字段的复用性。</p><ul><li>如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的</li><li>考虑空间-性能权衡</li></ul><h3 id="为何要用联合索引"><a class="markdownIt-Anchor" href="#为何要用联合索引"></a> 为何要用联合索引？</h3><ul><li>减少不必要的索引开销：(a, b, c)这样一个联合索引，可以提供对(a, b, c)，(a, b)，(a)的索引查询</li><li>可以使用覆盖索引：</li></ul><h2 id="42覆盖索引"><a class="markdownIt-Anchor" href="#42覆盖索引"></a> 4.2覆盖索引</h2><p>InnoDB存储引擎支持覆盖索引（covering index，或称索引覆盖），即<strong>从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录（不需要回表）</strong>。</p><h3 id="执行流程"><a class="markdownIt-Anchor" href="#执行流程"></a> 执行流程</h3><p>举个例子：<br />对于下图(name, age)联合索引，如下查询：</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> AGE <span class="token keyword">FROM</span> <span class="token keyword">USER</span> <span class="token keyword">WHERE</span> NAME<span class="token operator">=</span><span class="token string">'王五'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>执行流程：</p><ol><li>在(name,age)联合索引树上找到名称为王五的节点</li><li>该节点里包含age信息，直接返回10</li></ol><h3 id="为何使用覆盖索引"><a class="markdownIt-Anchor" href="#为何使用覆盖索引"></a> 为何使用覆盖索引？</h3><ul><li>使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以<strong>减少大量的IO操作，避免回表</strong>。</li><li>有利于某些统计操作，减少IO操作，例如count(*)</li></ul><h2 id="43索引下推"><a class="markdownIt-Anchor" href="#43索引下推"></a> 4.3索引下推</h2><p>满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？<br />举个例子：<br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659349509932-74d84a2a-bbd9-4ab6-87e3-d965e9a3df4d.jpeg#clientId=uc2bce005-9626-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=441&amp;id=u72411cba&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=818&amp;originWidth=1142&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=91771&amp;status=done&amp;style=none&amp;taskId=u8647e64a-94b9-4134-ac21-3a3e240d147&amp;title=%28name%2C%20age%29%20%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95&amp;width=616.0000610351562" alt="image.png" title="(name, age) 联合索引" /><br />对于如下查询，只能根据最左前缀匹配“张”来定位到ID3，之后判断 <code>age=10</code>和 <code>ismale=1</code>是否满足。</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tuser <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'张 %'</span> <span class="token operator">and</span> age<span class="token operator">=</span><span class="token number">10</span> <span class="token operator">and</span> ismale<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><ul><li>在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。</li><li>MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以<strong>在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659349959530-524c8319-c3d6-4333-aa83-e2fa03b1fdb8.jpeg#clientId=uc2bce005-9626-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=452&amp;id=ua21a9b35&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=833&amp;originWidth=1142&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=94058&amp;status=done&amp;style=none&amp;taskId=uad783a80-e5d2-465e-b13b-ddfaa2bdbe2&amp;title=%E6%97%A0%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8&amp;width=620.0000610351562" alt="image.png" title="无索引下推" /><br /><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/29351684/1659349984973-d0255af8-758a-43d4-9437-8f102910a1ec.jpeg#clientId=uc2bce005-9626-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=461&amp;id=u03a6278a&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=856&amp;originWidth=1142&amp;originalType=url&amp;ratio=1&amp;rotation=0&amp;showTitle=true&amp;size=95952&amp;status=done&amp;style=none&amp;taskId=uad22cb43-5dea-4dea-a737-e209f12d90f&amp;title=%E6%9C%89%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8&amp;width=615" alt="image.png" title="有索引下推" /><br />InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现LRU/LFU缓存</title>
    <link href="/2022/07/28/%E5%AE%9E%E7%8E%B0LRU-LFU%E7%BC%93%E5%AD%98/"/>
    <url>/2022/07/28/%E5%AE%9E%E7%8E%B0LRU-LFU%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="0前言"><a class="markdownIt-Anchor" href="#0前言"></a> 0.前言</h1><p>不管是计算机系统里的Cache缓存，还是现在流行的内存缓存，由于缓存容量的限制，都会设计淘汰算法，即选择哪一块“旧的”数据替换出去，用以存放“最新”的数据。<br />常见的淘汰算法有：</p><ul><li>FIFO：先进先出，最先进入缓存的数据，在缓存空间不足时被清除，为了保证最新数据可用，保证实时性</li><li>LRU（Least Recently Used）：最近最久未使用，基于访问次数，去除命中次数最少的元素，保证高频数据有效性</li><li>LFU（Least Frequently Used）：最不经常使用，基于访问时间，在被访问过的元素中去除最久未使用的元素，保证热点数据的有效性</li></ul><h1 id="1lru"><a class="markdownIt-Anchor" href="#1lru"></a> 1.LRU</h1><p>一般面试考察LRU的算法题，基本是考察点就是实现双链表，不太可能让你实现哈希表，所以哈希表直接用HashMap即可。<br />实现 LRUCache 类：</p><ul><li>LRUCache(int capacity) ：以 正整数 作为容量 capacity 初始化 LRU 缓存</li><li>int get(int key)： 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li>void put(int key, int value)： 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字</li></ul><p>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行</p><h2 id="实现思路"><a class="markdownIt-Anchor" href="#实现思路"></a> 实现思路</h2><ul><li>使用双链表来维护“最近最久未使用”性质，链表表头存放oldest的数据，表尾存放youngest的数据</li><li>使用哈希表来维护key-value键值对</li></ul><p>每次get时：</p><ul><li>如果key不存在，则直接返回-1</li><li>如果key存在，则先将该节点从链表中删除，然后将其插入链表末尾，标识刚刚访问过</li></ul><p>每次put时：</p><ul><li><p>如果key存在，则更新key对应的值为value，并且将该节点从链表中删除，然后将其插入链表末尾，标识刚刚访问过</p></li><li><p>如果key不存在，新建节点，放入哈希表中，并将节点放入链表尾部，随后判断缓存容量，如果超了，则执行替换：</p><ul><li>逐出“最近最久未使用”的节点，即表头节点，同时将对应的key从哈希表中删除</li></ul></li><li><p>注意：不可直接使用Java中的LinkedList，原因有二：</p><ul><li>LinkedList类的remove(int val)是通过逐个扫描比较来实现的，即时间复杂度O（1）</li><li>面试官的考点就是让你自己实现双链表</li></ul></li></ul><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token comment">// 双向链表维护LRU性质，head存放oldest,tail存放youngest</span>    <span class="token class-name">DoubleLinkedList</span> keyCache<span class="token punctuation">;</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">></span></span> map<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>keyCache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DoubleLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> node <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> node <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        keyCache<span class="token punctuation">.</span><span class="token function">removeSpecific</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        keyCache<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果存在，更新kv，更新lru</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span> node <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            node<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 删除当前访问的节点，放入最后</span>            keyCache<span class="token punctuation">.</span><span class="token function">removeSpecific</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            keyCache<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>            keyCache<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> capacity <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 逐出最近最久未使用</span>                <span class="token keyword">int</span> k_oldest <span class="token operator">=</span> keyCache<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>k_oldest<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> key<span class="token punctuation">;</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    <span class="token class-name">Node</span> pre<span class="token punctuation">;</span>    <span class="token class-name">Node</span> next<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>        pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">DoubleLinkedList</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 虚拟节点，统一操作</span>    <span class="token class-name">Node</span> head<span class="token punctuation">;</span>    <span class="token class-name">Node</span> tail<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">DoubleLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>        tail<span class="token punctuation">.</span>pre <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> tail_pre <span class="token operator">=</span> tail<span class="token punctuation">.</span>pre<span class="token punctuation">;</span>        tail_pre<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>pre <span class="token operator">=</span> tail_pre<span class="token punctuation">;</span>        tail<span class="token punctuation">.</span>pre <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> head_next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> head_next<span class="token punctuation">.</span>key<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> head_next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head_next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>pre <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">return</span> k<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">removeSpecific</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        node<span class="token punctuation">.</span>pre<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>pre <span class="token operator">=</span> node<span class="token punctuation">.</span>pre<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h1 id="2lfu"><a class="markdownIt-Anchor" href="#2lfu"></a> 2.LFU</h1><p>实现 LFUCache 类：</p><ul><li>LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象</li><li>int get(int key) - 如果键 key 存在于缓存中，则获取键的值，否则返回 -1 。</li><li>void put(int key, int value) - 如果键 key 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 capacity 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最近最久未使用 的键</li></ul><p>函数 get 和 put 必须以 O(1) 的平均时间复杂度运行</p><h2 id="实现思路-2"><a class="markdownIt-Anchor" href="#实现思路-2"></a> 实现思路</h2><ul><li>为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 ，使用计数最小的键是最久未使用的键</li><li>其他实现思路类似LRU</li></ul><h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LFUCache</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token keyword">int</span> minRef<span class="token punctuation">;</span>    <span class="token comment">// k -> node</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">></span></span> map<span class="token punctuation">;</span>    <span class="token comment">// ref -> dlist, 维护LRU</span>    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">DoubleLinkedList</span><span class="token punctuation">></span></span> refMap<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">LFUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>        minRef <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        refMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span> node <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 旧的引用计数链表中删除该节点</span>            refMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>ref<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeSpecific</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果dlist没有元素了，refMap中的key也要删除</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> refMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>ref<span class="token punctuation">)</span><span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                refMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 引用计数+1</span>            node<span class="token punctuation">.</span>ref<span class="token operator">++</span><span class="token punctuation">;</span>            minRef <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minRef<span class="token punctuation">,</span> node<span class="token punctuation">.</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// node插入新的引用计数(+1后的)链表</span>            <span class="token class-name">DoubleLinkedList</span> cur_ref_list <span class="token operator">=</span> refMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token keyword">null</span> <span class="token operator">==</span> cur_ref_list <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 新建链表</span>                cur_ref_list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DoubleLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cur_ref_list<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                refMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>ref<span class="token punctuation">,</span> cur_ref_list<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                cur_ref_list<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">return</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> capacity <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Node</span> node <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            node<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token comment">// 旧的refMap删除当前ref对应的kv</span>            refMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>ref<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeSpecific</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> refMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>ref<span class="token punctuation">)</span><span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                refMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            node<span class="token punctuation">.</span>ref<span class="token operator">++</span><span class="token punctuation">;</span>            minRef <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minRef<span class="token punctuation">,</span> node<span class="token punctuation">.</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">DoubleLinkedList</span> cur_ref_list <span class="token operator">=</span> refMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token keyword">null</span> <span class="token operator">==</span> cur_ref_list <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 新建链表</span>                cur_ref_list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DoubleLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cur_ref_list<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                refMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>ref<span class="token punctuation">,</span> cur_ref_list<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                cur_ref_list<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> capacity <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 先按minRef</span>                <span class="token class-name">DoubleLinkedList</span> min_ref_list <span class="token operator">=</span> refMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>minRef<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span> min_ref_list <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    min_ref_list <span class="token operator">=</span> refMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">++</span>minRef<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token comment">// 相同的minRef下，删除LRU</span>                <span class="token keyword">int</span> k <span class="token operator">=</span> min_ref_list<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span> min_ref_list<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    refMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>minRef<span class="token punctuation">)</span><span class="token punctuation">;</span>                    minRef<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            minRef <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minRef<span class="token punctuation">,</span> node<span class="token punctuation">.</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">DoubleLinkedList</span> cur_ref_list <span class="token operator">=</span> refMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>ref<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token keyword">null</span> <span class="token operator">==</span> cur_ref_list <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 新建链表</span>                cur_ref_list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DoubleLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                cur_ref_list<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                refMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>ref<span class="token punctuation">,</span> cur_ref_list<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                cur_ref_list<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> key<span class="token punctuation">;</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    <span class="token keyword">int</span> ref<span class="token punctuation">;</span>    <span class="token class-name">Node</span> pre<span class="token punctuation">;</span>    <span class="token class-name">Node</span> next<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>ref <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">DoubleLinkedList</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 虚拟节点，统一操作</span>    <span class="token class-name">Node</span> head<span class="token punctuation">;</span>    <span class="token class-name">Node</span> tail<span class="token punctuation">;</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">DoubleLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>        tail<span class="token punctuation">.</span>pre <span class="token operator">=</span> head<span class="token punctuation">;</span>        size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">addLast</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> tail_pre <span class="token operator">=</span> tail<span class="token punctuation">.</span>pre<span class="token punctuation">;</span>        tail_pre<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>pre <span class="token operator">=</span> tail_pre<span class="token punctuation">;</span>        tail<span class="token punctuation">.</span>pre <span class="token operator">=</span> node<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> head_next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> head_next<span class="token punctuation">.</span>key<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> head_next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head_next<span class="token punctuation">.</span>next<span class="token punctuation">.</span>pre <span class="token operator">=</span> head<span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> k<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">removeSpecific</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        node<span class="token punctuation">.</span>pre<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>pre <span class="token operator">=</span> node<span class="token punctuation">.</span>pre<span class="token punctuation">;</span>        size<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LRU</tag>
      
      <tag>LFU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL中的「锁」与「事务」</title>
    <link href="/2022/07/24/MySQL%E4%B8%AD%E7%9A%84%E3%80%8C%E9%94%81%E3%80%8D%E4%B8%8E%E3%80%8C%E4%BA%8B%E5%8A%A1%E3%80%8D/"/>
    <url>/2022/07/24/MySQL%E4%B8%AD%E7%9A%84%E3%80%8C%E9%94%81%E3%80%8D%E4%B8%8E%E3%80%8C%E4%BA%8B%E5%8A%A1%E3%80%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="0前言"><a class="markdownIt-Anchor" href="#0前言"></a> 0.前言</h1><p>一方面要最大程度地利用数据库的并发访问，另外一方面还要确保每个用户能以一致的方式读取和修改数据。因此，便有了「锁」，用于对共享资源的并发访问[1]。</p><p>事务（Transaction）是数据库区别于文件系统的重要特性之一。事务会把数据库从一种一致状态转换为另一种一致状态。在数据库提交工作时，可以确保要么所有修改都已经保存了，要么所有修改都不保存。<br />本文主要以InnoDB为例，学习锁和事务的设计与实现。</p><h1 id="1锁"><a class="markdownIt-Anchor" href="#1锁"></a> 1.锁</h1><h2 id="锁分类"><a class="markdownIt-Anchor" href="#锁分类"></a> 锁分类</h2><ul><li>悲观锁：认为数据随时会被修改，数据操纵过程中始终加锁</li><li>乐观锁：认为自己操作数据时，没有人修改数据，不加锁，但是更新时会判断在此期间有无他人修改（需编码实现，比如基于version、timestamp）</li></ul><p>通常，我们说的锁一般是悲观锁。以下，对悲观锁进行分类：</p><h3 id="按作用范围"><a class="markdownIt-Anchor" href="#按作用范围"></a> 按作用范围</h3><ul><li>表级锁：锁定整张表，封锁力度高，并发力度低，不会死锁<ul><li>InnoDB提供了 行锁 和 表锁，默认是 行锁</li></ul></li><li>行级锁：锁定行，并发力度高，开销也高，可能会死锁<ul><li>MyISAM提供 表锁</li></ul></li></ul><h3 id="按使用性质"><a class="markdownIt-Anchor" href="#按使用性质"></a> 按使用性质</h3><ul><li>共享锁（读锁/S锁）：允许事务读一行数据</li><li>排他锁（写锁/X锁）：允许事务删除或更新一行数据</li></ul><p><em><strong>注意</strong></em>：</p><ol><li>共享锁、排他锁都是行锁</li><li>锁兼容问题：<br /><font color=yellow>仅共享锁和共享锁之间可兼容，其他组合一律不兼容</font>。</li></ol><h2 id="锁的算法"><a class="markdownIt-Anchor" href="#锁的算法"></a> 锁的算法</h2><p>InnoDB有三种行锁的算法：</p><ul><li>Record Lock：单个行记录上的锁</li><li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身</li><li>Next-Key Lock：Recod Lock + Gap Lock，锁定一个范围，包含记录本身</li></ul><h2 id="锁带来的问题并发一致性问题"><a class="markdownIt-Anchor" href="#锁带来的问题并发一致性问题"></a> 锁带来的问题(并发一致性问题)</h2><p>通过锁定机制可以实现事务的隔离性要求，使得事务可以并发地工作。锁提高了并发，但是却会带来潜在的问题。不过好在因为事务隔离性的要求，锁只会带来三种问题，如果可以防止这三种情况的发生，那将不会产生并发异常。</p><h3 id="脏读-违反隔离性"><a class="markdownIt-Anchor" href="#脏读-违反隔离性"></a> 脏读-违反隔离性</h3><p>脏数据是指<font color=yellow>未提交</font>的数据，如果读到了脏数据，即一个事务可以读到另外一个事务中未提交的数据，则显然违反了数据库的隔离性。</p><p>脏读是指：在不同的事务下，当前事务可以读到其他事务未提交的数据，也就是读到了脏数据。发生条件是：事务的隔离级别是 <font color=yellow>READ UNCOMMITED</font>。</p><h3 id="不可重复读-违反一致性"><a class="markdownIt-Anchor" href="#不可重复读-违反一致性"></a> 不可重复读-违反一致性</h3><p>不可重复读是指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会不一样（<font color=yellow>行数据被修改</font>）。<br />不可重复读一般来说，也是可以接受的（<font color=yellow>数据已经提交</font>）。</p><blockquote><p>在InnoDB存储引擎中，通过使用Next-Key Lock算法来避免不可重复读的问题。在MySQL官方文档中将不可重复读的问题定义为Phantom Problem，即幻像问题。在Next-Key Lock算法下，对于索引的扫描，不仅是锁住扫描到的索引，而且还锁住这些索引覆盖的范围（gap）。因此在这个范围内的插入都是不允许的。这样就避免了另外的事务在这个范围内插入数据导致的不可重复读的问题。<br />–《MySQL技术内幕：InnoDB存储引擎》</p></blockquote><h3 id="幻读"><a class="markdownIt-Anchor" href="#幻读"></a> 幻读</h3><p>幻读是指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会<font color=yellow>返回之前不存在的行</font>。</p><p><em><strong>注意</strong></em>：<br />有时候，也把幻读放入不可重复读范畴。</p><h3 id="丢失更新"><a class="markdownIt-Anchor" href="#丢失更新"></a> 丢失更新</h3><p>一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致。</p><p>在当前数据库的任何隔离级别下，<strong>都不会导致数据库理论意义上的丢失更新问题</strong>。这是因为，即使是READ UNCOMMITTED的事务隔离级别，对于行的DML操作，需要对行或其他粗粒度级别的对象加锁。</p><p>但是在生产应用中还有另一个<strong>逻辑意义的丢失更新问题</strong>，而导致该问题的并不是因为数据库本身的问题。</p><h1 id="2事务"><a class="markdownIt-Anchor" href="#2事务"></a> 2.事务</h1><p>事务是访问并更新数据库中各种数据项的一个程序执行单元。在事务中的操作，要么都做修改，要么都不做，这就是事务的目的。</p><p><img src="https://pdai.tech/_images/pics/185b9c49-4c13-4241-a848-fbff85c03a64.png" alt="image" /></p><p><strong>对于InnoDB存储引擎而言，其默认的事务隔离级别为READ REPEATABLE</strong>，完全遵循和满足事务的ACID特性。<br />MySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p><p>这里，具体介绍事务的ACID特性，并给出相关概念。</p><h2 id="acid特性"><a class="markdownIt-Anchor" href="#acid特性"></a> ACID特性</h2><ul><li>A（Atomicity），原子性。<br />原子性指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL语句执行失败，已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。</li><li>C（consistency），一致性。一致性指事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</li><li>I（isolation），隔离性。隔离性还有其他的称呼，如并发控制（concurrency control）、可串行化（serializability）、锁（locking）等。事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，通常这使用锁来实现。</li><li>D（durability），持久性。事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复。</li></ul><p><font color=red><em><strong>注意：ACID不是平级的关系</strong></em></font></p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对数据库崩溃的情况。</li></ul><p><img src="https://pdai.tech/_images/pics/a58e294a-615d-4ea0-9fbf-064a6daec4b2.png" alt="image" /></p><h2 id="事务的分类"><a class="markdownIt-Anchor" href="#事务的分类"></a> 事务的分类</h2><ul><li>扁平事务（Flat Transactions）</li><li>带有保存点的扁平事务（Flat Transactions with Savepoints）</li><li>链事务（Chained Transactions）</li><li>嵌套事务（Nested Transactions）</li><li>分布式事务（Distributed Transactions）</li></ul><h2 id="事务隔离级别"><a class="markdownIt-Anchor" href="#事务隔离级别"></a> 事务隔离级别</h2><ul><li>未提交读(READ UNCOMMITTED)：事务中的修改，即使没有提交，对其它事务也是可见的</li><li>提交读(READ COMMITTED)：一个事务所做的修改在提交之前对其它事务是不可见的</li><li>可重复读(REPEATABLE READ)：保证在同一个事务中多次读取同样数据的结果是一样的</li><li>可串行化(SERIALIZABLE)：强制事务串行执行</li></ul><p>READ UNCOMMITTED称为浏览访问（browse access），仅仅针对事务而言的。READ COMMITTED称为游标稳定（cursor stability）。REPEATABLE READ是2.9999°的隔离，没有幻读的保护。SERIALIZABLE称为隔离，或3°的隔离。</p><table><thead><tr><th style="text-align:left">隔离级别</th><th style="text-align:center">脏读可能性</th><th style="text-align:center">不可重复读可能性</th><th style="text-align:right">幻读可能性</th></tr></thead><tbody><tr><td style="text-align:left">未提交读</td><td style="text-align:center">✓</td><td style="text-align:center">✓</td><td style="text-align:right">✓</td></tr><tr><td style="text-align:left">提交读</td><td style="text-align:center">✕</td><td style="text-align:center">✓</td><td style="text-align:right">✓</td></tr><tr><td style="text-align:left">可重复读</td><td style="text-align:center">✕</td><td style="text-align:center">✕</td><td style="text-align:right">✓</td></tr><tr><td style="text-align:left">可串行化</td><td style="text-align:center">✕</td><td style="text-align:center">✕</td><td style="text-align:right">✕</td></tr></tbody></table><blockquote><p>InnoDB存储引擎默认支持的隔离级别是REPEATABLE READ，但是与标准SQL不同的是，InnoDB存储引擎在REPEATABLE READ事务隔离级别下，使用Next-Key Lock锁的算法，因此避免幻读的产生。这与其他数据库系统（如Microsoft SQL Server数据库）是不同的。所以说，InnoDB存储引擎在默认的REPEATABLE READ的事务隔离级别下已经能完全保证事务的隔离性要求，即达到SQL标准的SERIALIZABLE隔离级别。</p><p>隔离级别越低，事务请求的锁越少或保持锁的时间就越短。这也是为什么大多数数据库系统默认的事务隔离级别是READ COMMITTED。</p></blockquote><h2 id="事务的实现"><a class="markdownIt-Anchor" href="#事务的实现"></a> 事务的实现</h2><ul><li>隔离性：由锁实现</li><li>原子性、持久性：由redo log实现<ul><li>redo log 是InnoDB 引擎层特有</li><li>物理日志，记录“某个数据页上做了什么修改”</li><li>循环写的，空间固定会用完</li><li>保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe</li><li>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log 里面，并更新内存，这个时候更新就算完成了。</li><li>同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做</li></ul></li><li>一致性：由undo log实现<!-- - Server层实现undo log，所有引擎都可用- 逻辑日志，记录“语句的原始逻辑”-  追加写，不会覆盖以前的日志 --><ul><li>undo log 是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子</li><li>记录了事务的行为，可以很好地通过其对页进行“重做”操作</li><li>undo log 会产生 redo log</li></ul></li></ul><h1 id="3多版本并发控制mvcc"><a class="markdownIt-Anchor" href="#3多版本并发控制mvcc"></a> 3.多版本并发控制（MVCC）</h1><blockquote><p>MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC）。不仅是MySQL，包括Oracle、PostgreSQL等其他数据库系统也都实现了MVCC，但各自的实现机制不尽相同，因为MVCC没有一个统一的实现标准。</p></blockquote><ul><li>可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</li><li><font color=yellow>MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作</font>。其他两个隔离级别都和MVCC不兼容，因为READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁。</li></ul><h2 id="innodb实现"><a class="markdownIt-Anchor" href="#innodb实现"></a> InnoDB实现</h2><p>MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p><ul><li>创建时间</li><li>过期时间</li></ul><p>InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。<font color=yellow>这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）</font>。当然存储的并不是实际的时间值，而是***系统版本号（system version number）***。</p><p>每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。下面看一下在REPEATABLE READ隔离级别下，MVCC具体是如何操作的。</p><h3 id="select"><a class="markdownIt-Anchor" href="#select"></a> SELECT</h3><ul><li>InnoDB只查找版本早于当前事务版本的数据行（确保事务读取的行，要么已存在，要么是事务自身插入/修改的）</li><li>行的删除版本要么未定义，要么大于当前事务版本号（确保事务读取到的行，在事务开始之前未被删除）</li></ul><h3 id="insert"><a class="markdownIt-Anchor" href="#insert"></a> INSERT</h3><ul><li>InnoDB为新插入的每一行保存当前系统版本号作为行版本号</li></ul><h3 id="delete"><a class="markdownIt-Anchor" href="#delete"></a> DELETE</h3><ul><li>InnoDB为删除的每一行保存当前系统版本号作为行删除标识</li></ul><h3 id="update"><a class="markdownIt-Anchor" href="#update"></a> UPDATE</h3><ul><li>InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识</li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>锁</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「分布式ID」生成方案</title>
    <link href="/2022/07/22/%E3%80%8C%E5%88%86%E5%B8%83%E5%BC%8FID%E3%80%8D%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/"/>
    <url>/2022/07/22/%E3%80%8C%E5%88%86%E5%B8%83%E5%BC%8FID%E3%80%8D%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>全局唯一ID，用于唯一标识一个实体（用户、产品等）。在传统的单机架构下，一种常用的做法是使用数据库自增ID来作为主键，唯一标识一个实体。但是在分布式架构下，虽然可以设置自增起始值和自增步长来实现但是受限于业务规模，难以扩展，且受限于DB性能瓶颈。</p><p>现有的分布式全局唯一ID可大致分为如下三类：</p><ul><li>UUID</li><li>基于DB</li><li>基于雪花ID(Snowflake)方案</li></ul><h2 id="需满足的条件"><a class="markdownIt-Anchor" href="#需满足的条件"></a> 需满足的条件</h2><ul><li>全局唯一：必须保证ID是全局性唯一的，基本要求</li><li>高性能：高可用低延时，ID生成响应要块，否则反倒会成为业务瓶颈</li><li>高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用性</li><li>好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单</li><li>趋势递增：最好趋势递增，这个要求就得看具体业务场景了，一般不严格要求</li></ul><h1 id="1uuid"><a class="markdownIt-Anchor" href="#1uuid"></a> 1.UUID</h1><p>UUID （Universally Unique Identifier），通用唯一识别码的缩写。UUID是由一组32位数的16进制数字所构成，所以UUID理论上的总数为 16<sup>32=2</sup>128，约等于 3.4 x 10^38。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。</p><p>生成的UUID是由 8-4-4-4-12格式的数据组成，其中32个字符和4个连字符’ - '，一般我们使用的时候会将连字符删除。</p><h2 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h2><ul><li>本地生成，无网络消耗</li></ul><h2 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h2><ul><li>占用空间较大，不易存储，通常用varchar存储</li><li>无业务意义，完全是一串随机字符串</li><li>不是趋势自增，插入DB会引起B+树页分裂和节点分裂</li></ul><h1 id="2mysql自增id"><a class="markdownIt-Anchor" href="#2mysql自增id"></a> 2.MySQL自增ID</h1><p>使用MySQL自增ID来作为全局唯一ID是一种常用做法</p><h2 id="单机"><a class="markdownIt-Anchor" href="#单机"></a> 单机</h2><p>单机下，直接设置 从1开始自增<code>auto_increment_offset=1</code>，增量为1 <code>auto_increment_increment=1</code>，每次发号时，向DB插入一条数据，将主键作为ID</p><h3 id="优点-2"><a class="markdownIt-Anchor" href="#优点-2"></a> 优点</h3><ul><li>实现简单</li></ul><h3 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h3><ul><li>不满足高可用，DB有宕机风险</li></ul><h2 id="集群"><a class="markdownIt-Anchor" href="#集群"></a> 集群</h2><p>既然单机存在宕机风险，那么部署一个MySQL集群呗，设置双主集群，两个节点都能发号。</p><p>MySQL A配置-发单号</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">auto_increment_offset<span class="token operator">=</span><span class="token number">1</span>auto_increment_increment<span class="token operator">=</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>MySQL B配置-发双号</p><div class="code-wrapper"><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">auto_increment_offset<span class="token operator">=</span><span class="token number">2</span>auto_increment_increment<span class="token operator">=</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div><p>如果后续还是扛不住并发，需要继续扩展，那就比较麻烦了。。。并且还存在着集群同步问题。</p><h3 id="优点-3"><a class="markdownIt-Anchor" href="#优点-3"></a> 优点</h3><ul><li>解决DB单点问题</li></ul><h3 id="缺点-3"><a class="markdownIt-Anchor" href="#缺点-3"></a> 缺点</h3><ul><li>存在集群同步问题</li><li>不易扩展</li></ul><h1 id="3基于redis实现"><a class="markdownIt-Anchor" href="#3基于redis实现"></a> 3.基于Redis实现</h1><p>Redis实现分布式唯一ID主要是通过提供像 <code>INCR</code> 和 <code>INCRBY</code> 这样的自增原子命令，由于Redis自身的<strong>单线程</strong>的特点所以能保证生成的 ID 是唯一有序的。 但是单机存在性能瓶颈，无法满足高并发的业务需求，可以采用集群的方式来实现。</p><p>此外，高并发场景下，最好使用Lua脚本来进行编码，保证完全的原子性操作。</p><h2 id="优点-4"><a class="markdownIt-Anchor" href="#优点-4"></a> 优点</h2><ul><li>ID自增，利于B+树索引</li><li>实现简单，性能较高</li></ul><h2 id="缺点-4"><a class="markdownIt-Anchor" href="#缺点-4"></a> 缺点</h2><ul><li>需引入Redis，提高系统复杂性</li></ul><h1 id="4雪花算法"><a class="markdownIt-Anchor" href="#4雪花算法"></a> 4.雪花算法</h1><p>雪花算法是Twitter开源的基于系统时间戳的分布式ID方案，以划分命名空间的方式将64bit分割为多个部分。</p><ul><li>第1位占用1bit，其值始终是0，可看做是符号位不使用</li><li>第2位开始的41位是时间戳，41-bit位可表示2^41个数，每个数代表毫秒，那么雪花算法可用的时间年限是(1L&lt;&lt;41)/(1000L360024*365)=69 年的时间</li><li>中间的10-bit位可表示机器数，即2^10 = 1024台机器，但是一般情况下我们不会部署这么台机器。如果我们对IDC（互联网数据中心）有需求，还可以将 10-bit 分 5-bit 给 IDC，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，具体的划分可以根据自身需求定义</li><li>最后12-bit位是自增序列，可表示2^12 = 4096个数。</li></ul><p>以下是Java实现。其中<code>nextId()</code>是使用synchronized加锁的，虽然synchronized只在单实例下有效，在集群部署下，通过设置不同的worker id，也可以保证ID的全局唯一性。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * twitter的snowflake算法 -- java实现 * https://github.com/beyondfengyu/SnowFlake/blob/master/SnowFlake.java * @author beyond * @date 2016/11/26 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SnowFlake</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/**     * 起始的时间戳     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> START_STMP <span class="token operator">=</span> <span class="token number">1480166465631L</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 每一部分占用的位数     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> SEQUENCE_BIT <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span> <span class="token comment">//序列号占用的位数</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> MACHINE_BIT <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>   <span class="token comment">//机器标识占用的位数</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> DATACENTER_BIT <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment">//数据中心占用的位数</span>    <span class="token comment">/**     * 每一部分的最大值     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> MAX_DATACENTER_NUM <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">&lt;&lt;</span> DATACENTER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> MAX_MACHINE_NUM <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">&lt;&lt;</span> MACHINE_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> MAX_SEQUENCE <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">&lt;&lt;</span> SEQUENCE_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 每一部分向左的位移     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> MACHINE_LEFT <span class="token operator">=</span> SEQUENCE_BIT<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> DATACENTER_LEFT <span class="token operator">=</span> SEQUENCE_BIT <span class="token operator">+</span> MACHINE_BIT<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">long</span> TIMESTMP_LEFT <span class="token operator">=</span> DATACENTER_LEFT <span class="token operator">+</span> DATACENTER_BIT<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> datacenterId<span class="token punctuation">;</span>  <span class="token comment">//数据中心</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> machineId<span class="token punctuation">;</span>     <span class="token comment">//机器标识</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> sequence <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span> <span class="token comment">//序列号</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> lastStmp <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1L</span><span class="token punctuation">;</span><span class="token comment">//上一次时间戳</span>    <span class="token keyword">public</span> <span class="token class-name">SnowFlake</span><span class="token punctuation">(</span><span class="token keyword">long</span> datacenterId<span class="token punctuation">,</span> <span class="token keyword">long</span> machineId<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>datacenterId <span class="token operator">></span> MAX_DATACENTER_NUM <span class="token operator">||</span> datacenterId <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"datacenterId can't be greater than MAX_DATACENTER_NUM or less than 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>machineId <span class="token operator">></span> MAX_MACHINE_NUM <span class="token operator">||</span> machineId <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"machineId can't be greater than MAX_MACHINE_NUM or less than 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>datacenterId <span class="token operator">=</span> datacenterId<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>machineId <span class="token operator">=</span> machineId<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 产生下一个ID     *     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">long</span> <span class="token function">nextId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> currStmp <span class="token operator">=</span> <span class="token function">getNewstmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>currStmp <span class="token operator">&lt;</span> lastStmp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Clock moved backwards.  Refusing to generate id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>currStmp <span class="token operator">==</span> lastStmp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//相同毫秒内，序列号自增</span>            sequence <span class="token operator">=</span> <span class="token punctuation">(</span>sequence <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> MAX_SEQUENCE<span class="token punctuation">;</span>            <span class="token comment">//同一毫秒的序列数已经达到最大</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sequence <span class="token operator">==</span> <span class="token number">0L</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                currStmp <span class="token operator">=</span> <span class="token function">getNextMill</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">//不同毫秒内，序列号置为0</span>            sequence <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        lastStmp <span class="token operator">=</span> currStmp<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>currStmp <span class="token operator">-</span> START_STMP<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> TIMESTMP_LEFT <span class="token comment">//时间戳部分</span>                <span class="token operator">|</span> datacenterId <span class="token operator">&lt;&lt;</span> DATACENTER_LEFT       <span class="token comment">//数据中心部分</span>                <span class="token operator">|</span> machineId <span class="token operator">&lt;&lt;</span> MACHINE_LEFT             <span class="token comment">//机器标识部分</span>                <span class="token operator">|</span> sequence<span class="token punctuation">;</span>                             <span class="token comment">//序列号部分</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> <span class="token function">getNextMill</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> mill <span class="token operator">=</span> <span class="token function">getNewstmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>mill <span class="token operator">&lt;=</span> lastStmp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            mill <span class="token operator">=</span> <span class="token function">getNewstmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> mill<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> <span class="token function">getNewstmp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">SnowFlake</span> snowFlake <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SnowFlake</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>snowFlake<span class="token punctuation">.</span><span class="token function">nextId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="优点-5"><a class="markdownIt-Anchor" href="#优点-5"></a> 优点</h2><ul><li>独立部署，不依赖其他组件</li><li>趋势递增</li><li>高性能</li><li>字段定义灵活</li></ul><h2 id="缺点-5"><a class="markdownIt-Anchor" href="#缺点-5"></a> 缺点</h2><ul><li>时钟回拨问题，会导致发号重复或者服务会处于不可用状态</li><li>ID字段结构暴露，容易暴露业务规模</li></ul><h2 id="针对时钟回拨问题的解决方案"><a class="markdownIt-Anchor" href="#针对时钟回拨问题的解决方案"></a> 针对时钟回拨问题的解决方案</h2><ul><li>抛出异常（时间被追回之前的这段时间服务不可用）</li><li>关闭机器时钟同步</li><li>保存过去一段时间内每台机器在当前这一毫秒产生的最大ID（max_id），如果发生回拨，则max_id+1即可</li><li>每次生成时，预留一些ID号段，发生回拨，将这些ID分配出去</li></ul><h2 id="实战应用"><a class="markdownIt-Anchor" href="#实战应用"></a> 实战应用</h2><p>在之前神州信息分布式赛道中，我跟刘哥使用了雪花ID作为分布式ID方案。赛题给定的主键字段是20位字符型，由于设计之初考虑到了单表容量过大的问题，采用了分库分表策略，将2位库标识+4位表标识设计到ID前六位，还剩下14位可用。因此，我们提出了一种基于雪花算法的分布式ID方案。</p><h3 id="id设计"><a class="markdownIt-Anchor" href="#id设计"></a> ID设计</h3><p>2位库标识+4位表标识+14位IceFlake ID</p><h3 id="基于snowflake的iceflake-id设计"><a class="markdownIt-Anchor" href="#基于snowflake的iceflake-id设计"></a> 基于SnowFlake的IceFlake ID设计</h3><ul><li>64位long类型存储</li><li>低6位：序列号，可标识2^6=64个id</li><li>次低4位：实例id标识位，可标识2^4=16个实例</li><li>中间41位：毫秒级时间戳，可标识时间范围：2^41/1000/60/60/24/365=69年</li><li>剩余高位：0填充</li></ul><p>最后，截取低52位，转为14位16进制比特位字符串（高位填充1个“0”），组成14位 Iceflake id</p><p>代码实现：</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SnowFlakeIdUtils</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 2015-01-01</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> START_DATE <span class="token operator">=</span> <span class="token number">1420041600000L</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> NUM_WORKER_ID_BITS <span class="token operator">=</span> <span class="token number">4L</span><span class="token punctuation">;</span>    <span class="token comment">// 序列号位数：6， 一个毫秒单位内可单个实例承受并发64个ID</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> NUM_SEQUENCE_ID_BITS <span class="token operator">=</span> <span class="token number">6L</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> NUM_WORKER_ID_SHIFTS <span class="token operator">=</span> NUM_SEQUENCE_ID_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> NUM_TIMESTAMP_ID_SHIFTS <span class="token operator">=</span> NUM_SEQUENCE_ID_BITS <span class="token operator">+</span> NUM_WORKER_ID_BITS<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> SEQUENCE_MASK <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1L</span> <span class="token operator">&lt;&lt;</span> NUM_SEQUENCE_ID_BITS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 集群部署，配置worker-id</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;worker-id&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> workerId<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> sequenceId<span class="token operator">=</span><span class="token number">0L</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> lastTimestamp<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1L</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">String</span> <span class="token function">getSnowflakeId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> time_stamp <span class="token operator">=</span> <span class="token function">getCurrentTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// TODO: 优化时钟回拨错误</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> time_stamp <span class="token operator">&lt;</span> lastTimestamp <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>                    <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"clock moved backward! Failed to generate Snowflake ID for %d millisecond..."</span><span class="token punctuation">,</span> lastTimestamp <span class="token operator">-</span> time_stamp<span class="token punctuation">)</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 如果是同一时间生成，则序列号+1</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> lastTimestamp <span class="token operator">==</span> time_stamp <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            sequenceId <span class="token operator">=</span> <span class="token punctuation">(</span>sequenceId <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> SEQUENCE_MASK<span class="token punctuation">;</span>            <span class="token comment">// 序列溢出</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> sequenceId <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                time_stamp <span class="token operator">=</span> <span class="token function">tilNextMillis</span><span class="token punctuation">(</span>lastTimestamp<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 否则，从0开始</span>            sequenceId <span class="token operator">=</span> <span class="token number">0L</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        lastTimestamp <span class="token operator">=</span> time_stamp<span class="token punctuation">;</span>        <span class="token comment">// 往14位填充</span>        <span class="token keyword">return</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%14s"</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">.</span><span class="token function">toHexString</span><span class="token punctuation">(</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>time_stamp <span class="token operator">-</span> START_DATE<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> NUM_TIMESTAMP_ID_SHIFTS<span class="token punctuation">)</span>                        <span class="token operator">|</span> <span class="token punctuation">(</span>workerId <span class="token operator">&lt;&lt;</span> NUM_WORKER_ID_SHIFTS<span class="token punctuation">)</span>                        <span class="token operator">|</span> sequenceId<span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">,</span> <span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 阻塞到下一个毫秒，直到获得新的时间戳     * @param lastTimestamp     * @return     */</span>    <span class="token keyword">protected</span> <span class="token keyword">long</span> <span class="token function">tilNextMillis</span><span class="token punctuation">(</span><span class="token keyword">long</span> lastTimestamp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">long</span> time_stamp <span class="token operator">=</span> <span class="token function">getCurrentTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span> time_stamp <span class="token operator">&lt;=</span> lastTimestamp <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            time_stamp <span class="token operator">=</span> <span class="token function">getCurrentTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> time_stamp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">protected</span> <span class="token keyword">long</span> <span class="token function">getCurrentTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>分布式系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式ID</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「TOP K」问题的几种解法</title>
    <link href="/2022/06/01/%E3%80%8CTOP%20K%E3%80%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E6%B3%95/"/>
    <url>/2022/06/01/%E3%80%8CTOP%20K%E3%80%8D%E9%97%AE%E9%A2%98%E7%9A%84%E5%87%A0%E7%A7%8D%E8%A7%A3%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="序言"><a class="markdownIt-Anchor" href="#序言"></a> 序言</h1><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>O</mi><mi>P</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">TOP K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 问题应该是面试必问的算法题了，通常是问数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> 中第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 大或者第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 小的元素。<br />通常有如下几种解法：</p><ul><li>直接排序</li><li>优先队列（大根堆/小根堆）</li><li>快速选择（基于快排的划分）</li></ul><p>本文以 <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">LC 215. 数组中的第K个最大元素</a>为例分析。</p><h1 id="直接排序"><a class="markdownIt-Anchor" href="#直接排序"></a> 直接排序</h1><p>这里贴一个快排模板，需要注意的是，每次划分中pivot的选取对快排性能影响很大，极端情况下（数组逆序）时间复杂度会退化到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。常见的解决方案是 <em><strong>三者取中</strong></em>，即首尾和中间，取其中位数。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">quick_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> piv <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span> left <span class="token operator">&lt;</span> right <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// right找比piv小的</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span> left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> piv <span class="token punctuation">)</span> right<span class="token operator">--</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span> left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> piv <span class="token punctuation">)</span> left<span class="token operator">++</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// piv放入最终位置</span>        nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> piv<span class="token punctuation">;</span>        <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> left <span class="token operator">&lt;</span> right <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> piv_index <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">quick_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> piv_index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">quick_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> piv_index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ul><li><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，极端情况下退化到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p></li><li><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，递归调用栈的开销</p></li></ul><h1 id="优先队列"><a class="markdownIt-Anchor" href="#优先队列"></a> 优先队列</h1><p>优先队列，也就是堆。对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>O</mi><mi>P</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">TOP K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 大的元素，维护大小为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 的小根堆，不断将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span> 中的元素送进去，最终堆顶元素就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>O</mi><mi>P</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">TOP K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 大的元素。</p><ul><li>为什么是小根堆而不是大根堆？</li><li>如果用大根堆，就要对全量元素进行全部排序；反之，维护一个大小为k的小根堆，最终留下的堆顶，就是topk大</li></ul><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> x <span class="token operator">:</span> nums <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            pq<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> pq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> k <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                pq<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> pq<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ul><li><p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>，遍历元素 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，堆调整 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></p></li><li><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></p></li></ul><h1 id="快速选择"><a class="markdownIt-Anchor" href="#快速选择"></a> 快速选择</h1><p>快速排序的每次划分，会确定一个pivot元素的最终位置，在pivot左边的元素都比pivot小；右边的都比pivot大（但都不一定有序）。</p><p>快速选择基于快速排序的划分思想，每次划分之后，得到pivot元素的下标，并不像快速排序那样递归地对左右两个子区间进行分治处理。</p><p>而是判断当前pivot元素的下标 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>v</mi><mi>o</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">pivot\_idx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span> 和待求 topk 元素的下标 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi><mi>x</mi><mo>:</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mo>−</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">k\_idx := nums.length-k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span> 作比较，如果：</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>v</mi><mi>o</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi><mi>x</mi><mo>=</mo><mo>=</mo><mi>k</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">pivot\_idx == k\_idx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span>，直接返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>p</mi><mi>i</mi><mi>v</mi><mi>o</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi><mi>x</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[pivot\_idx]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">p</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mclose">]</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>v</mi><mi>o</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi><mi>x</mi><mo>&gt;</mo><mi>k</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">pivot\_idx &gt; k\_idx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span>，说明目标的K应该在左半区间，则递归在左半区间进行处理</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>i</mi><mi>v</mi><mi>o</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi><mi>x</mi><mo>&lt;</mo><mi>k</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">pivot\_idx &lt; k\_idx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span></span></span></span>，说明目标的K应该在右半区间，则递归在右半区间进行处理</li></ul><p>可以看出，相对于朴素快排，快速选择相当于进行了一次“二分”剪枝处理，每次划分完之后，并没有像快速排序那样对左右两个子区间都进行递归处理。</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">quick_select</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> piv <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span> left <span class="token operator">&lt;</span> right <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// right找比piv小的</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span> left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> piv <span class="token punctuation">)</span> right<span class="token operator">--</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span> left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> piv <span class="token punctuation">)</span> left<span class="token operator">++</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// piv放入最终位置</span>        nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> piv<span class="token punctuation">;</span>        <span class="token keyword">return</span> left<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">quick_select</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> k_index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> left <span class="token operator">&lt;</span> right <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> piv_idx <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> k_index <span class="token operator">==</span> piv_idx <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// topk 索引比piv索引大</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> k_index <span class="token operator">></span> piv_idx <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 往右搜索</span>                <span class="token function">quick_select</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> piv_idx<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> k_index<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token function">quick_select</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> piv_idx<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> k_index<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ul><li><p><em><strong>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，具体证明参见《算法导论》</strong></em></p></li><li><p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，递归调用栈的开销</p></li></ul><h1 id="写在后面"><a class="markdownIt-Anchor" href="#写在后面"></a> 写在后面</h1><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>O</mi><mi>P</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">TOP K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> 问题作为算法题来考察，主要还是考察「快速选择」的，因此务必要掌握。除此之外，如果涉及到海量数据处理，可能需要用到外部排序，MapReduce处理等。</p><p>最后，再贴一个堆排序和归并排序的模板。</p><h2 id="堆排序模板"><a class="markdownIt-Anchor" href="#堆排序模板"></a> 堆排序模板</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sortArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> res<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// n-1趟交换和建堆</span>            <span class="token function">swap</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 堆顶和堆底交换（输出堆顶）</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 把剩下的i-1个元素调整成堆</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 初始建堆</span>    <span class="token keyword">void</span> <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 从 [n/2] ~ 1,调整堆</span>            <span class="token function">adjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 调整k为根的子树为大根堆</span>    <span class="token keyword">void</span> <span class="token function">adjust</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// nums[0]暂存当前根节点</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>k<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> len<span class="token punctuation">;</span> i <span class="token operator">*=</span> <span class="token number">2</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> i <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                k <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><h2 id="归并排序模板"><a class="markdownIt-Anchor" href="#归并排序模板"></a> 归并排序模板</h2><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> low <span class="token operator">&lt;</span> high <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high<span class="token operator">-</span>low<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token function">merge_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">merge_sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 合并</span>            <span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 合并两个有序子数组[low,mid] 和 [mid+1, high]</span>    <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>high<span class="token operator">-</span>low<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> low<span class="token punctuation">,</span> j <span class="token operator">=</span> mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span> i <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> high <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                tmp<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                tmp<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">// 左边的大于右边的，说明 mid+1 ~ i 之间的都是逆序对</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 剩余的直接复制过去</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span> i <span class="token operator">&lt;=</span> mid <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            tmp<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span> j <span class="token operator">&lt;=</span> high <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            tmp<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>tmp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> tmp<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速选择</tag>
      
      <tag>优先队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「区间和」问题</title>
    <link href="/2022/05/18/%E3%80%8C%E5%8C%BA%E9%97%B4%E5%92%8C%E3%80%8D%E9%97%AE%E9%A2%98/"/>
    <url>/2022/05/18/%E3%80%8C%E5%8C%BA%E9%97%B4%E5%92%8C%E3%80%8D%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="区间和"><a class="markdownIt-Anchor" href="#区间和"></a> 区间和</h2><p>对于数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>，所谓「区间和」，就是求解数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">nums</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>中区间<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[i,j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>的元素和：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]+nums[i+1]+\cdots+nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></span></p><p>使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的空间复杂度来实现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>时间复杂度的快速计算，来代替逐个累加的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>暴力计算</p><h2 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h2><ul><li>数组不可变：可用「前缀和」、「树状数组」、「线段树」<ul><li>一维前缀和</li><li>二维前缀和</li></ul></li><li>数组可变：「前缀和」不适用<ul><li>单点修改</li><li>区间修改</li></ul></li></ul><h2 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h2><p>所谓「前缀和」，就是用一个数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>S</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">preSum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>来记录从<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>之间的元素和，</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>S</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>p</mi><mi>r</mi><mi>e</mi><mi>S</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">preSum[i] = preSum[i-1]+nums[i] </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></span></p><p>为了解决数组越界问题，通常多申请一个空间，使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>S</mi><mi>u</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">preSum</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span>下标从1开始。</p><h3 id="一维前缀和"><a class="markdownIt-Anchor" href="#一维前缀和"></a> 一维前缀和</h3><p><a href="https://leetcode.cn/problems/range-sum-query-immutable/">LC 303. 区域和检索 - 数组不可变</a></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">NumArray</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pre_sum<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">NumArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// pre_sum[1]开始</span>        pre_sum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            pre_sum<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> pre_sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sumRange</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> pre_sum<span class="token punctuation">[</span>right<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> pre_sum<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul><h3 id="二维前缀和"><a class="markdownIt-Anchor" href="#二维前缀和"></a> 二维前缀和</h3><p><a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">LC 304. 二维区域和检索 - 矩阵不可变</a></p><p>方法一 维护每一行/列的一维前缀和</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">NumMatrix</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 维护每一行的前缀和</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> pres<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">NumMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">,</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        pres <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                pres<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> pres<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sumRegion</span><span class="token punctuation">(</span><span class="token keyword">int</span> row1<span class="token punctuation">,</span> <span class="token keyword">int</span> col1<span class="token punctuation">,</span> <span class="token keyword">int</span> row2<span class="token punctuation">,</span> <span class="token keyword">int</span> col2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> row1<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> row2<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            res <span class="token operator">+=</span> <span class="token punctuation">(</span>pres<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>col2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> pres<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>col1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，每次检索区间和：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul><p>方法二 维护二维前缀和</p><p>初始考虑四个单元格:</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>S</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>p</mi><mi>r</mi><mi>e</mi><mi>S</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>p</mi><mi>r</mi><mi>e</mi><mi>S</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>−</mo><mi>p</mi><mi>r</mi><mi>e</mi><mi>S</mi><mi>u</mi><mi>m</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">                    preSum[i + 1][j + 1] = preSum[i][j + 1] + preSum[i + 1][j] - preSum[i][j] + matrix[i][j];</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">;</span></span></span></span></span></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">NumMatrix</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> preSum<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">NumMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        preSum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 下标仍然从1开始</span>                preSum<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> preSum<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">sumRegion</span><span class="token punctuation">(</span><span class="token keyword">int</span> row1<span class="token punctuation">,</span> <span class="token keyword">int</span> col1<span class="token punctuation">,</span> <span class="token keyword">int</span> row2<span class="token punctuation">,</span> <span class="token keyword">int</span> col2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// preSum[row1][col1]被减了两次，最后加上</span>        <span class="token keyword">return</span> preSum<span class="token punctuation">[</span>row2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>col2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> preSum<span class="token punctuation">[</span>row1<span class="token punctuation">]</span><span class="token punctuation">[</span>col2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> preSum<span class="token punctuation">[</span>row2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>col1<span class="token punctuation">]</span> <span class="token operator">+</span> preSum<span class="token punctuation">[</span>row1<span class="token punctuation">]</span><span class="token punctuation">[</span>col1<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div><ul><li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，检索区间和：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li><li>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></li></ul><h2 id="树状数组"><a class="markdownIt-Anchor" href="#树状数组"></a> 树状数组</h2><p>如果区间可变/可修改，那么「前缀和」应该就失效了，这时候可以使用「树状数组」、「线段树」，由于「线段树」实现起来比「树状数组」复杂，且多数情况下的问题都可以用「树状数组」实现，所以这里暂且只介绍「树状数组」</p><p>模板</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 上来先把三个方法写出来</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tree<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">lowbit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> x <span class="token operator">&amp;</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 查询前缀和的方法</span>    <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> x<span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">-=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>             ans <span class="token operator">+=</span> tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 在树状数组 x 位置中增加值 u</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> x<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>             tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> u<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 初始化「树状数组」，要默认数组是从 1 开始</span><span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>         <span class="token function">add</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 使用「树状数组」：</span><span class="token punctuation">&#123;</span>       <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 原有的值是 nums[i]，要使得修改为 val，需要增加 val - nums[i]</span>        <span class="token function">add</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> val <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> <span class="token function">sumRange</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">query</span><span class="token punctuation">(</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">query</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>作者：<span class="token class-name">AC_OIer</span>链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>leetcode<span class="token punctuation">.</span>cn<span class="token operator">/</span>problems<span class="token operator">/</span>range<span class="token operator">-</span>sum<span class="token operator">-</span>query<span class="token operator">-</span>mutable<span class="token operator">/</span>solution<span class="token operator">/</span>guan<span class="token operator">-</span>yu<span class="token operator">-</span>ge<span class="token operator">-</span>lei<span class="token operator">-</span>qu<span class="token operator">-</span>jian<span class="token operator">-</span>he<span class="token operator">-</span>wen<span class="token operator">-</span>ti<span class="token operator">-</span>ru<span class="token operator">-</span>he<span class="token operator">-</span>x<span class="token operator">-</span><span class="token number">41</span>hv<span class="token operator">/</span>来源：力扣（<span class="token class-name">LeetCode</span>）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀和</tag>
      
      <tag>区间和</tag>
      
      <tag>树状数组</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「Trie树」的实现</title>
    <link href="/2022/05/16/%E3%80%8CTrie%E6%A0%91%E3%80%8D%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/05/16/%E3%80%8CTrie%E6%A0%91%E3%80%8D%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>r</mi><mi>i</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Trie</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span></span></span></span> 树，又叫 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⌈</mo></mrow><annotation encoding="application/x-tex">\lceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span></span></span></span> 前缀树 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">⌋</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⌈</mo></mrow><annotation encoding="application/x-tex">\lceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span></span></span></span> 字典树 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">⌋</span></span></span></span>，是一种多叉树，用来进行快速前缀匹配的一种数据结构。</p><p>与一般多叉树不同的是，</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>r</mi><mi>i</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Trie</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span></span></span></span> 的节点不存储节点信息，仅仅存放一个标记位 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>s</mi><mi>E</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">isEnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span> ，用来标记当前节点是否是路径的终点，即从 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mi>o</mi><mi>o</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">root</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">t</span></span></span></span> 到当前节点是一个单词。</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>r</mi><mi>i</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Trie</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span></span></span></span> 的节点信息存放在树枝中。</li></ul><h2 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h2><ul><li>前缀匹配</li><li>单词补全</li><li>单词纠错</li></ul><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><ol><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>r</mi><mi>i</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Trie</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span></span></span></span> 节点定义</p> <div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">boolean</span> isEnd<span class="token punctuation">;</span>          <span class="token comment">// 是否是单词结尾</span>    <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> children<span class="token punctuation">;</span>     <span class="token comment">// 26叉树</span>    <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        isEnd <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>r</mi><mi>i</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Trie</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span></span></span></span> 建立</p><p>对于给定的字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">word</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span>，遍历其每个字符，一次在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>r</mi><mi>i</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Trie</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span></span></span></span> 中检查其是否存在，</p><ul><li>如果存在，则继续往下查找；</li><li>如果不存在，则在对应分支上创建节点，继续往下查找。直至遍历完 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">word</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span></li></ul><p>最后，置 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>s</mi><mi>E</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">isEnd=true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span>，表示以该节点为结尾的字符串是一个完整的单词</p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">TrieNode</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">-</span><span class="token char">'a'</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 新建节点</span>            p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 往下迭代</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 标记为单词结尾</span>    p<span class="token punctuation">.</span>isEnd <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>查找整个字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">word</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span></span></span></span></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">TrieNode</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">-</span><span class="token char">'a'</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 如果word最后一个字符是单词结尾，则查找成功；否则，word只是trie中的一个前缀</span>    <span class="token keyword">return</span> p<span class="token punctuation">.</span>isEnd<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>查找前缀 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>f</mi><mi>i</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">prefix</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span></span></span></span></p><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token class-name">String</span> prefix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">TrieNode</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prefix<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> prefix<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">-</span><span class="token char">'a'</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        p <span class="token operator">=</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 查找到prefix，说明trie中肯定存在以prefix为前缀的单词</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li><li><p>完整代码</p> <div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">TrieNode</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">boolean</span> isEnd<span class="token punctuation">;</span>          <span class="token comment">// 是否是单词结尾</span>    <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token punctuation">]</span> children<span class="token punctuation">;</span>     <span class="token comment">// 26叉树</span>    <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        isEnd <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">class</span> <span class="token class-name">Trie</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// trie树，边存放字符信息，节点标记是否是单词结尾，及后续字符是什么</span>    <span class="token class-name">TrieNode</span> root<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Trie</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">TrieNode</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">-</span><span class="token char">'a'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 新建节点</span>                p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrieNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 往下迭代</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 标记为单词结尾</span>        p<span class="token punctuation">.</span>isEnd <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token class-name">String</span> word<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">TrieNode</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">-</span><span class="token char">'a'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 如果word最后一个字符是单词结尾，则查找成功；否则，word只是trie中的一个前缀</span>        <span class="token keyword">return</span> p<span class="token punctuation">.</span>isEnd<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token class-name">String</span> prefix<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">TrieNode</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> prefix<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> prefix<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">-</span><span class="token char">'a'</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>children<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 查找到prefix，说明trie中肯定存在以prefix为前缀的单词</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法与数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前缀树</tag>
      
      <tag>Trie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/05/16/hello-world/"/>
    <url>/2022/05/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
